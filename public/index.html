<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CUA Annahme</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header class="topbar app-topbar">
      <div class="brand app-brand">
        <img src="/assets/cua-logo.png" alt="CUA Logo" />
      </div>
      <h1 class="app-brand-title">CUA Annahme</h1>
      <div class="topbar-actions">
        <button type="button" id="open-package-builder-modal" class="secondary topbar-icon-btn" title="Paket Builder" aria-label="Paket Builder">🧰</button>
        <button type="button" id="open-customers-modal" class="secondary topbar-icon-btn" title="Kunden" aria-label="Kunden">👤</button>
        <button type="button" id="theme-toggle" class="secondary theme-toggle topbar-icon-btn" title="Theme wechseln" aria-label="Theme wechseln">◐</button>
        <a class="topbar-icon-btn secondary" href="/settings.html" title="Settings" aria-label="Settings">⚙</a>
      </div>
    </header>

    <main class="app-main" style="max-width:min(1800px, 98vw); margin:0 auto; padding:0 14px;">
      <form id="order-form" class="order-layout">
        <section class="head-section">
          <div class="head-header-row">
            <h2 class="section-title" style="display:none;">Kopf</h2>
            <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; width:100%;">
              <div id="topbar-left" class="head-action-row">
                <button type="button" id="new-order-btn" class="secondary head-action-btn" title="Neuer Auftrag" aria-label="Neuer Auftrag">Neu</button>
                <button type="button" id="new-order-same-project-btn" class="secondary head-action-btn" title="Neuer Auftrag gleiches Projekt" aria-label="Neuer Auftrag gleiches Projekt">Neu gleiches Projekt</button>
              </div>
              <div id="topbar-right" class="head-action-row" style="justify-content:flex-end;">
                <button type="submit" form="order-form" id="draft-btn" class="secondary head-action-btn" title="Erstellt eine Vorschau ohne in Excel zu schreiben" aria-label="Vorschau">Vorschau</button>
                <button type="button" id="commit-btn" class="primary head-action-btn hidden" title="Schreibt den Auftrag in die geöffnete Annahme Excel" aria-label="In Excel schreiben">In Excel schreiben</button>
                <button type="button" id="retry-commit-btn" class="secondary head-action-btn hidden" title="Erneut versuchen" aria-label="Erneut versuchen">Erneut versuchen</button>
              </div>
            </div>
          </div>
          <div id="commit-feedback" class="feedback" role="status" aria-live="polite"></div>
          <details id="error-panel" class="error-panel hidden">
            <summary>Details</summary>
            <pre id="error-details"></pre>
          </details>
          <div id="page-layout" style="display:grid; grid-template-columns: 220px minmax(0, 1fr); gap: 12px; align-items:start;">
            <aside id="head-sidebar" style="position: sticky; top: 76px; max-height: calc(100vh - 90px); overflow: hidden; padding: 10px; border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; background: rgba(0,0,0,0.25);">
              <div style="display:flex; flex-direction:column; gap:6px;">
                <input id="kunde" name="kunde" list="kunden-options" placeholder="Kunde" style="height:32px; font-size:13px;" />
                <datalist id="kunden-options"></datalist>

                <input id="ansprechpartner" name="ansprechpartner" placeholder="Ansprechpartner" style="height:32px; font-size:13px;" />

                <div class="head-inline-actions head-inline-actions-helper" style="margin-bottom:6px; gap:4px;">
                  <button type="button" id="open-address-modal" class="secondary" style="width:100%; min-height:64px; font-size:13px; position:relative; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:2px; padding:6px 28px 6px 10px;" title="Keine Anschrift">
                    <span id="address-line-1" style="max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; line-height:1.2;">Anschrift</span>
                    <span id="address-line-2" style="max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; line-height:1.2;"></span>
                    <span id="address-line-3" style="max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; line-height:1.2;"></span>
                    <span id="address-indicator" class="note-indicator hidden" aria-hidden="true" style="position:absolute; top:6px; right:8px;"></span>
                  </button>
                  <span id="adresse-preview" class="mini-hint" style="display:none;">Keine Anschrift</span>
                </div>

                <input id="email" name="email" type="email" placeholder="Email" style="height:32px; font-size:13px;" />
                <input id="projektnummer" name="projektnummer" placeholder="Projektnummer" style="height:32px; font-size:13px;" />
                <input id="projektName" name="projektName" placeholder="Projekt" style="height:32px; font-size:13px;" />
                <input id="probenahmedatum" name="probenahmedatum" type="date" class="head-input-date" placeholder="Probenahme" aria-label="Probenahme" title="Datum der Probenahme" style="height:32px; font-size:13px;" />

                <div id="samplers-wrap" class="head-inline-actions head-inline-actions-helper" style="display:flex; flex-direction:column; align-items:flex-start; gap:6px; margin-bottom:6px;">
                  <button type="button" id="open-samplers-modal" class="secondary" style="width:100%; height:32px; font-size:13px;">
                    <span id="samplers-button-label">Probenehmer</span>
                    <span id="samplers-indicator" class="note-indicator hidden" aria-hidden="true"></span>
                  </button>
                </div>

                <div class="field-eilig head-toggle-wrap" style="margin-bottom:6px;">
                  <button type="button" id="eilig-toggle" class="switch-toggle" role="switch" aria-checked="false" data-value="nein" style="height:32px; font-size:13px;">
                    <span class="switch-toggle-label">Eilig</span>
                    <span class="switch-toggle-value">Aus</span>
                  </button>
                  <input type="hidden" id="eilig-value" name="eilig" value="nein" />
                </div>

                <div class="field-transport head-toggle-wrap" style="margin-bottom:6px;">
                  <button type="button" id="probentransport-toggle" class="switch-toggle switch-toggle-transport" role="switch" aria-checked="false" data-value="CUA" style="height:32px; font-size:13px;">
                    <span class="switch-toggle-label">Transport</span>
                    <span class="switch-toggle-value">CUA</span>
                  </button>
                  <input type="hidden" id="probentransport-value" name="probentransport" value="CUA" />
                </div>

                <div class="field-kuerzel" style="margin-bottom:6px;">
                  <input id="erfasstKuerzel" name="erfasstKuerzel" maxlength="4" class="head-input-kuerzel hidden" readonly />
                  <button type="button" id="open-kuerzel-modal" class="secondary head-field-btn" style="width:100%; height:32px; font-size:13px;">Kürzel</button>
                </div>

                <button type="button" id="open-kopfbemerkung-modal" class="secondary head-note-btn" title="Keine Kopfbemerkung" style="width:100%; height:32px; font-size:13px; margin-bottom:6px;">
                  <span id="kopf-bemerkung-button-label">Kopfbemerkung</span>
                  <span id="kopf-bemerkung-indicator" class="note-indicator hidden" aria-hidden="true"></span>
                </button>

                <label for="probeNochNichtDa" class="inline-checkbox compact-inline-checkbox">
                  <input id="probeNochNichtDa" name="probeNochNichtDa" type="checkbox" />
                  Probe noch nicht da
                </label>
              </div>
              <input id="adresseBlock" name="adresseBlock" type="hidden" />
              <input id="probenEingangDatum" name="probenEingangDatum" type="date" class="head-input-date hidden" />
              <textarea id="kopfBemerkung" name="kopfBemerkung" class="hidden"></textarea>
            </aside>
            <main id="main-content" style="min-width:0; width:100%;">
              <section class="sample-section">
                <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                  <h2 class="section-title" style="margin:0;">Probenliste</h2>
                  <div style="display:flex; align-items:center; gap:8px; flex-wrap:nowrap;">
                    <button type="button" id="add-probe" class="secondary" title="Probe hinzufügen" aria-label="Probe hinzufügen">Probe +</button>
                    <button type="button" id="open-bulk-probe-modal" class="secondary" title="Mehrere Proben einfügen" aria-label="Mehrere Proben einfügen">Mehrere Proben</button>
                  </div>
                </div>
                <div class="same-set-row">
                  <label for="same-containers-for-all" class="inline-checkbox">
                    <input id="same-containers-for-all" name="sameContainersForAll" type="checkbox" />
                    Gebinde gelten für gesamten Auftrag
                  </label>
                  <button type="button" id="open-header-gebinde-modal" class="secondary hidden">Gebinde Auftrag...</button>
                  <span id="header-gebinde-summary" class="gebinde-summary">-</span>
                </div>

                <div class="probes-table-wrap">
                  <table class="probes-table" style="font-size:13px;">
                    <thead style="position:sticky; top:0; z-index:2;">
                      <tr>
                        <th style="width:28%; min-width:320px; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Probenbezeichnung</th>
                        <th style="min-width:240px; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Paket + Einzel</th>
                        <th style="min-width:120px; white-space:normal; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Material</th>
                        <th style="width:90px; min-width:90px; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Gewicht</th>
                        <th style="width:52px; min-width:52px; text-align:center; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Gebinde</th>
                        <th style="width:110px; min-width:110px; text-align:right; padding-top:6px; padding-bottom:6px; position:sticky; top:0; z-index:2; background:var(--surface);">Aktionen</th>
                      </tr>
                    </thead>
                    <tbody id="proben-container"></tbody>
                  </table>
                </div>
              </section>
            </main>
          </div>
        </section>
      </form>
    </main>

    <template id="probe-template">
      <tr class="probe-row">
        <td style="padding-top:6px; padding-bottom:6px; width:28%; min-width:320px;">
          <textarea name="probenbezeichnung" rows="1" style="width:100%; resize:none; overflow:hidden; min-height:30px; height:30px; padding:4px 8px; line-height:1.25;"></textarea>
          <input name="probenbezeichnungFull" type="hidden" />
          <input name="tiefeVolumen" type="hidden" />
        </td>
        <td style="padding-top:6px; padding-bottom:6px; min-width:240px;">
          <div style="display:flex; gap:8px; align-items:center;">
            <select name="packageId" style="height:30px; padding:4px 8px; flex:1 1 auto; min-width:0;">
              <option value="">Bitte wählen</option>
            </select>
            <button type="button" data-action="single-params" title="Einzelparameter" aria-label="Einzelparameter" style="height:24px; min-width:46px; padding:0 8px; font-size:12px; line-height:1; opacity:0.86; position:relative;">
              Einzel
              <span data-single-params-indicator class="hidden" aria-hidden="true" style="position:absolute; top:3px; right:3px; width:7px; height:7px; border-radius:50%; background:#e53935;"></span>
            </button>
          </div>
          <input name="parameterTextPreview" type="hidden" />
          <input name="singleParamsJson" type="hidden" />
          <input name="packageAddonsJson" type="hidden" />
        </td>
        <td style="padding-top:6px; padding-bottom:6px; min-width:120px;">
          <select name="material" style="height:30px; padding:4px 8px; width:100%;">
            <option value="Boden">Boden</option>
            <option value="Wasser">Wasser</option>
            <option value="Feststoff">Feststoff</option>
          </select>
        </td>
        <td style="padding-top:6px; padding-bottom:6px; width:90px; min-width:90px;">
          <input name="gewicht" type="number" min="0" step="any" placeholder="kg" style="height:30px; padding:4px 8px; max-width:90px; width:90px; text-align:right;" />
        </td>
        <td style="padding-top:6px; padding-bottom:6px; width:52px; min-width:52px; text-align:center;">
          <button type="button" data-action="gebinde" class="secondary icon-btn" title="Keine Gebinde" aria-label="Gebinde auswählen" style="position:relative;">◐
            <span data-gebinde-indicator class="hidden" aria-hidden="true" style="position:absolute; top:3px; right:3px; width:7px; height:7px; border-radius:50%; background:#e53935;"></span>
          </button>
          <span class="gebinde-summary hidden" data-gebinde-summary>-</span>
          <input name="containersJson" type="hidden" />
        </td>
        <td style="width:110px; min-width:110px; text-align:right; padding-top:6px; padding-bottom:6px;">
          <div class="probe-actions-inline" style="justify-content:flex-end;">
            <button type="button" data-action="geruch" class="secondary icon-btn" title="Geruch wählen" aria-label="Geruch wählen" style="position:relative;">◍
              <span data-geruch-indicator class="hidden" aria-hidden="true" style="position:absolute; top:3px; right:3px; width:7px; height:7px; border-radius:50%; background:#e53935;"></span>
            </button>
            <span class="gebinde-summary hidden" data-geruch-summary>-</span>
            <button type="button" data-action="probe-note" class="secondary icon-btn" title="Keine Bemerkung" aria-label="Bemerkung" style="width:30px; height:30px; min-width:30px; padding:0; display:inline-flex; align-items:center; justify-content:center; position:relative;">
            <span aria-hidden="true" style="font-size:15px; line-height:1;">🗒</span>
            <span data-probe-note-indicator class="hidden" aria-hidden="true" style="position:absolute; top:3px; right:3px; width:7px; height:7px; border-radius:50%; background:#e53935;"></span>
            </button>
            <input name="geruchOption" type="hidden" />
            <input name="geruchSonstiges" type="hidden" />
            <input name="bemerkung" type="hidden" />
            <button type="button" data-action="duplicate" class="secondary icon-btn" title="Duplizieren" aria-label="Duplizieren">◐</button>
            <button type="button" data-action="delete" class="secondary icon-btn" title="Löschen" aria-label="Löschen">◐</button>
          </div>
        </td>
      </tr>
    </template>

    <div id="bulk-probe-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="bulk-probe-modal-title">
      <div class="modal-card">
        <h3 id="bulk-probe-modal-title">Probenliste einfügen</h3>
        <p class="meta" style="margin: 0 0 0.5rem;">Eine Probenbezeichnung pro Zeile. Leere Zeilen ignorieren.</p>
        <textarea id="bulk-probe-modal-text" rows="12"></textarea>
        <div class="check-row" style="margin-top:0.5rem;">
          <input id="bulk-copy-from-first" type="checkbox" checked />
          <span>Parameter und Gebinde von erster Probe kopieren</span>
        </div>
        <fieldset id="bulk-probe-mode-wrap" style="margin-top: 0.7rem;">
          <legend>Vorhandene Proben</legend>
          <div class="radio-group">
            <label><input type="radio" name="bulk-probe-mode" value="append" checked /> Anhängen</label>
            <label><input type="radio" name="bulk-probe-mode" value="replace" /> Ersetzen</label>
          </div>
        </fieldset>
        <div class="modal-actions">
          <button type="button" id="bulk-probe-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="bulk-probe-modal-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>

    <div id="gebinde-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="gebinde-modal-title">
      <div class="modal-card">
        <h3 id="gebinde-modal-title">Gebinde auswählen</h3>
        <div class="modal-tabs" role="tablist" aria-label="Gebinde Typ">
          <button type="button" class="secondary" data-tab="plastic">Kunststoff</button>
          <button type="button" class="secondary" data-tab="glass">Glas</button>
        </div>
        <div class="grid" style="grid-template-columns: 1fr; gap: 0.45rem;">
          <div>
            <label for="gebinde-preview">Vorschau</label>
            <textarea id="gebinde-preview" rows="2" readonly></textarea>
          </div>
        </div>
        <div id="gebinde-buttons-wrap" class="quick-buttons-grid"></div>
        <div class="actions" style="margin-top: 0.6rem;">
          <button type="button" id="gebinde-undo" class="secondary">Undo</button>
          <button type="button" id="gebinde-reset" class="secondary">Reset</button>
        </div>
        <div class="modal-actions">
          <button type="button" id="gebinde-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="gebinde-modal-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>

    <div id="geruch-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="geruch-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="geruch-modal-title">Geruch wählen</h3>
        <div class="grid" style="grid-template-columns: 1fr; gap: 0.45rem;">
          <div>
            <label for="geruch-option">Option</label>
            <select id="geruch-option">
              <option value="unauffaellig">unauffällig</option>
              <option value="muffig">muffig</option>
              <option value="mineralisch">mineralisch</option>
              <option value="loesungsmittelartig">lösungsmittelartig</option>
              <option value="faulig">faulig</option>
              <option value="sonstiges">sonstiges</option>
            </select>
          </div>
          <div id="geruch-sonstiges-wrap" class="hidden">
            <label for="geruch-sonstiges">Sonstiges</label>
            <input id="geruch-sonstiges" type="text" />
          </div>
        </div>
        <div class="modal-actions">
          <button type="button" id="geruch-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="geruch-modal-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>

    <div id="kuerzel-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="kuerzel-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="kuerzel-modal-title">Kürzel wählen</h3>
        <div id="kuerzel-buttons-wrap" class="quick-buttons-grid kuerzel-buttons-grid"></div>
        <div class="grid" style="grid-template-columns: 1fr auto; gap: 0.45rem; margin-top: 0.55rem;">
          <input id="kuerzel-custom-input" type="text" placeholder="Eigener Eintrag" />
          <button type="button" id="kuerzel-custom-apply" class="primary">Übernehmen</button>
        </div>
        <div class="modal-actions">
          <button type="button" id="kuerzel-modal-reset" class="secondary">Reset Leeren</button>
          <button type="button" id="kuerzel-modal-close" class="secondary">Schließen</button>
        </div>
      </div>
    </div>

    <div id="kopf-bemerkung-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="kopf-bemerkung-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="kopf-bemerkung-modal-title">Kopfbemerkung</h3>
        <textarea id="kopf-bemerkung-modal-text" rows="7" placeholder="Kopfbemerkung eingeben..."></textarea>
        <div class="modal-actions">
          <button type="button" id="kopf-bemerkung-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="kopf-bemerkung-modal-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>

    <div id="probe-note-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="probe-note-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="probe-note-modal-title">Bemerkung</h3>
        <textarea id="probe-note-text" rows="8" style="width:100%;" placeholder="Bemerkung eingeben..."></textarea>
        <div class="modal-actions">
          <button type="button" id="probe-note-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="probe-note-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>


    <div id="customers-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="customers-modal-title">
      <div class="modal-card modal-card-medium">
        <h3 id="customers-modal-title">Kunden</h3>
        <div class="grid" style="grid-template-columns: 1fr auto auto; gap: 0.45rem;">
          <input id="customers-search" type="text" placeholder="Kunde suchen..." />
          <button type="button" id="customers-refresh-from-excel" class="secondary">Aus Excel aktualisieren</button>
          <button type="button" id="customers-modal-close" class="secondary">Schließen</button>
        </div>
        <div id="customers-list" class="customers-list" role="listbox" aria-label="Kundenliste"></div>
      </div>
    </div>

    <div id="important-fields-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="important-fields-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="important-fields-modal-title">Wichtige Felder fehlen</h3>
        <ul id="important-fields-list" class="missing-fields-list"></ul>
        <div class="modal-actions">
          <button type="button" id="important-fields-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="important-fields-proceed" class="primary">Trotzdem fortfahren</button>
        </div>
      </div>
    </div>

    <div id="customer-delete-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="customer-delete-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="customer-delete-modal-title">Kunde wirklich löschen</h3>
        <p id="customer-delete-modal-text" class="meta"></p>
        <div class="modal-actions">
          <button type="button" id="customer-delete-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="customer-delete-confirm" class="secondary danger">Löschen</button>
        </div>
      </div>
    </div>

    <div id="address-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="address-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="address-modal-title">Anschrift</h3>
        <div class="grid" style="grid-template-columns: 1fr 120px; gap: 0.45rem;">
          <div style="grid-column: 1 / span 2;">
            <label for="address-firma">Firma Name</label>
            <input id="address-firma" type="text" required />
          </div>
          <div style="grid-column: 1 / span 2;">
            <label for="address-zh">zH (optional)</label>
            <input id="address-zh" type="text" />
          </div>
          <div>
            <label for="address-strasse">Straße</label>
            <input id="address-strasse" type="text" />
          </div>
          <div>
            <label for="address-hausnummer">Hausnummer</label>
            <input id="address-hausnummer" type="text" />
          </div>
          <div>
            <label for="address-plz">PLZ</label>
            <input id="address-plz" type="text" />
          </div>
          <div>
            <label for="address-ort">Ort</label>
            <input id="address-ort" type="text" />
          </div>
          <div style="grid-column: 1 / span 2;">
            <label for="address-preview-block">Vorschau</label>
            <textarea id="address-preview-block" rows="4" readonly></textarea>
          </div>
        </div>
        <div class="modal-actions">
          <button type="button" id="address-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="address-modal-apply" class="primary">Speichern</button>
        </div>
      </div>
    </div>

    <div id="samplers-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="samplers-modal-title">
      <div class="modal-card modal-card-small">
        <h3 id="samplers-modal-title">Probenehmer wählen</h3>
        <div id="samplers-modal-buttons-wrap" class="quick-buttons-grid" style="margin-top:0.45rem;"></div>
        <div class="modal-actions">
          <button type="button" id="samplers-modal-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="samplers-modal-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>
    <div id="single-params-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="single-params-modal-title" style="overflow: hidden;">
      <div class="modal-card" style="width: min(1200px, 95vw); max-height: 92vh; display: flex; flex-direction: column; overflow: hidden;">
        <h3 id="single-params-modal-title">Einzelparameter</h3>
        <p id="single-params-package-warning" class="meta hidden"></p>
        <div id="single-params-body" style="display: grid; grid-template-columns: 1fr 1.2fr; gap: 16px; flex: 1 1 auto; min-height: 0;">
          <div style="display: flex; flex-direction: column; min-height: 0;">
            <div id="single-params-search-wrap" style="position: sticky; top: 0; background: inherit; z-index: 2; padding-bottom: 8px; flex: 0 0 auto;">
              <label for="single-params-search">Suche</label>
              <input id="single-params-search" type="text" placeholder="Parameter suchen..." />
            </div>
            <div id="single-params-list" class="list-editor" style="max-height: 70vh; overflow-y: auto; flex: 1 1 auto; min-height: 0;"></div>
          </div>
          <div style="display: flex; flex-direction: column; min-height: 0; gap: 10px;">
            <div id="selected-params-list" class="list-editor" style="flex: 1 1 auto; max-height: 58vh; overflow-y: auto; min-height: 0;"></div>
            <div style="flex: 0 0 auto; display: flex; flex-direction: column;">
              <label for="single-params-preview">Vorschau</label>
              <div id="single-params-preview" style="height: 180px; min-height: 180px; max-height: 200px; overflow-y: auto; resize: vertical; border: 1px solid var(--line); border-radius: 8px; padding: 0.55rem 0.6rem; background: var(--surface-2); white-space: pre-wrap;"></div>
            </div>
          </div>
        </div>
        <div class="modal-actions" style="flex: 0 0 auto;">
          <button type="button" id="single-params-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="single-params-apply" class="primary">Übernehmen</button>
        </div>
      </div>
    </div>
    <div id="package-builder-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="package-builder-modal-title" style="overflow: hidden;">
      <div class="modal-card" style="width: min(1200px, 95vw); max-height: 92vh; display: flex; flex-direction: column; overflow: hidden;">
        <h3 id="package-builder-modal-title">Paket erstellen</h3>
        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:8px;">
          <label for="package-builder-name">Paketname</label>
          <input id="package-builder-name" type="text" placeholder="Paketname" />
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1.2fr; gap: 16px; flex: 1 1 auto; min-height: 0;">
          <div style="display: flex; flex-direction: column; min-height: 0;">
            <div style="position: sticky; top: 0; background: inherit; z-index: 2; padding-bottom: 8px; flex: 0 0 auto;">
              <label for="package-builder-search">Suche</label>
              <input id="package-builder-search" type="text" placeholder="Parameter suchen..." />
            </div>
            <div id="package-builder-list" class="list-editor" style="max-height: 70vh; overflow-y: auto; flex: 1 1 auto; min-height: 0;"></div>
          </div>
          <div style="display: flex; flex-direction: column; min-height: 0; gap: 10px;">
            <div id="package-builder-selected-list" class="list-editor" style="flex: 1 1 auto; max-height: 58vh; overflow-y: auto; min-height: 0;"></div>
            <div style="flex: 0 0 auto; display: flex; flex-direction: column;">
              <label for="package-builder-preview">Vorschau</label>
              <div id="package-builder-preview" style="height: 180px; min-height: 180px; max-height: 200px; overflow-y: auto; resize: vertical; border: 1px solid var(--line); border-radius: 8px; padding: 0.55rem 0.6rem; background: var(--surface-2); white-space: pre-wrap;"></div>
            </div>
          </div>
        </div>
        <div class="modal-actions" style="flex: 0 0 auto;">
          <button type="button" id="package-builder-cancel" class="secondary">Abbrechen</button>
          <button type="button" id="package-builder-save" class="primary">Speichern</button>
        </div>
      </div>
    </div>
    <div id="toast-container" class="toast-wrap"></div>

    <script src="/shared/parameterTextBuilder.js"></script>
    <script>
      const THEME_KEY = 'cua-theme';
      const themeToggle = document.getElementById('theme-toggle');
      function applyTheme(theme) {
        const resolved = theme === 'light' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', resolved);
        localStorage.setItem(THEME_KEY, resolved);
        if (themeToggle) {
          themeToggle.textContent = '◐';
          themeToggle.title = resolved === 'dark' ? 'Zu Light wechseln' : 'Zu Dark wechseln';
        }
      }
      applyTheme(localStorage.getItem(THEME_KEY) || 'dark');
      if (themeToggle) {
        themeToggle.addEventListener('click', () => {
          const current = document.documentElement.getAttribute('data-theme') || 'dark';
          applyTheme(current === 'dark' ? 'light' : 'dark');
        });
      }

      const toastContainer = document.getElementById('toast-container');
      function showToast(type, message) {
        const el = document.createElement('div');
        el.className = `toast ${type || 'info'}`;
        el.textContent = String(message || '');
        toastContainer.appendChild(el);
        setTimeout(() => {
          el.remove();
        }, 4200);
      }

      function setButtonLoading(button, isLoading, loadingLabel, idleLabel) {
        if (!button) return;
        if (isLoading) {
          if (!button.dataset.lockWidthPx) {
            button.dataset.lockWidthPx = String(Math.ceil(button.getBoundingClientRect().width));
          }
          button.style.minWidth = `${button.dataset.lockWidthPx}px`;
        } else {
          button.style.minWidth = '';
          delete button.dataset.lockWidthPx;
        }
        button.disabled = isLoading;
        button.classList.toggle('loading', isLoading);
        if (loadingLabel || idleLabel) {
          if (!button.dataset.idleLabel) {
            button.dataset.idleLabel = idleLabel || button.textContent.trim();
          }
          const resolvedIdle = idleLabel || button.dataset.idleLabel;
          if (isLoading && loadingLabel) {
            button.textContent = loadingLabel;
          } else {
            button.textContent = resolvedIdle;
          }
        }
      }

      const probenContainer = document.getElementById('proben-container');
      const probeTemplate = document.getElementById('probe-template');
      const newOrderButton = document.getElementById('new-order-btn');
      const openCustomersModalButton = document.getElementById('open-customers-modal');
      const newOrderSameProjectButton = document.getElementById('new-order-same-project-btn');
      const addProbeButton = document.getElementById('add-probe');
      const openBulkProbeModalButton = document.getElementById('open-bulk-probe-modal');
      const draftButton = document.getElementById('draft-btn');
      const commitButton = document.getElementById('commit-btn');
      const form = document.getElementById('order-form');
      const errorPanel = document.getElementById('error-panel');
      const errorDetails = document.getElementById('error-details');
      const kundenOptions = document.getElementById('kunden-options');
      const probeNochNichtDaInput = document.getElementById('probeNochNichtDa');
      const probenahmedatumInput = document.getElementById('probenahmedatum');
      const probenEingangDatumInput = document.getElementById('probenEingangDatum');
      const openSamplersModalButton = document.getElementById('open-samplers-modal');
      const samplersIndicator = document.getElementById('samplers-indicator');
      const samplersButtonLabel = document.getElementById('samplers-button-label');
      const samplersModal = document.getElementById('samplers-modal');
      const samplersModalButtonsWrap = document.getElementById('samplers-modal-buttons-wrap');
      const samplersModalCancel = document.getElementById('samplers-modal-cancel');
      const samplersModalApply = document.getElementById('samplers-modal-apply');
      const openKopfBemerkungModalButton = document.getElementById('open-kopfbemerkung-modal');
      const kopfBemerkungButtonLabel = document.getElementById('kopf-bemerkung-button-label');
      const kopfBemerkungIndicator = document.getElementById('kopf-bemerkung-indicator');
      const kopfBemerkungModal = document.getElementById('kopf-bemerkung-modal');
      const kopfBemerkungModalText = document.getElementById('kopf-bemerkung-modal-text');
      const kopfBemerkungModalCancel = document.getElementById('kopf-bemerkung-modal-cancel');
      const kopfBemerkungModalApply = document.getElementById('kopf-bemerkung-modal-apply');
      const probeNoteModal = document.getElementById('probe-note-modal');
      const probeNoteText = document.getElementById('probe-note-text');
      const probeNoteCancel = document.getElementById('probe-note-cancel');
      const probeNoteApply = document.getElementById('probe-note-apply');
      const bulkProbeModal = document.getElementById('bulk-probe-modal');
      const bulkProbeModalText = document.getElementById('bulk-probe-modal-text');
      const bulkCopyFromFirstInput = document.getElementById('bulk-copy-from-first');
      const bulkProbeModalCancel = document.getElementById('bulk-probe-modal-cancel');
      const bulkProbeModalApply = document.getElementById('bulk-probe-modal-apply');
      const bulkProbeModeWrap = document.getElementById('bulk-probe-mode-wrap');
      const gebindeModal = document.getElementById('gebinde-modal');
      const gebindeModalTitle = document.getElementById('gebinde-modal-title');
      const gebindePreviewInput = document.getElementById('gebinde-preview');
      const gebindeButtonsWrap = document.getElementById('gebinde-buttons-wrap');
      const gebindeUndoButton = document.getElementById('gebinde-undo');
      const gebindeResetButton = document.getElementById('gebinde-reset');
      const gebindeModalCancel = document.getElementById('gebinde-modal-cancel');
      const gebindeModalApply = document.getElementById('gebinde-modal-apply');
      const sameContainersForAllInput = document.getElementById('same-containers-for-all');
      const openHeaderGebindeModalButton = document.getElementById('open-header-gebinde-modal');
      const headerGebindeSummary = document.getElementById('header-gebinde-summary');
      const retryCommitButton = document.getElementById('retry-commit-btn');
      const commitFeedback = document.getElementById('commit-feedback');
      const eiligToggle = document.getElementById('eilig-toggle');
      const eiligValueInput = document.getElementById('eilig-value');
      const probentransportToggle = document.getElementById('probentransport-toggle');
      const probentransportValueInput = document.getElementById('probentransport-value');
      const geruchModal = document.getElementById('geruch-modal');
      const geruchOptionInput = document.getElementById('geruch-option');
      const geruchSonstigesWrap = document.getElementById('geruch-sonstiges-wrap');
      const geruchSonstigesInput = document.getElementById('geruch-sonstiges');
      const geruchModalCancel = document.getElementById('geruch-modal-cancel');
      const geruchModalApply = document.getElementById('geruch-modal-apply');
      const openKuerzelModalButton = document.getElementById('open-kuerzel-modal');
      const kuerzelModal = document.getElementById('kuerzel-modal');
      const kuerzelButtonsWrap = document.getElementById('kuerzel-buttons-wrap');
      const kuerzelCustomInput = document.getElementById('kuerzel-custom-input');
      const kuerzelCustomApply = document.getElementById('kuerzel-custom-apply');
      const kuerzelModalReset = document.getElementById('kuerzel-modal-reset');
      const kuerzelModalClose = document.getElementById('kuerzel-modal-close');
      const customersModal = document.getElementById('customers-modal');
      const customersSearchInput = document.getElementById('customers-search');
      const customersList = document.getElementById('customers-list');
      const customersModalClose = document.getElementById('customers-modal-close');
      const customersRefreshFromExcelButton = document.getElementById('customers-refresh-from-excel');
      const importantFieldsModal = document.getElementById('important-fields-modal');
      const importantFieldsList = document.getElementById('important-fields-list');
      const importantFieldsCancel = document.getElementById('important-fields-cancel');
      const importantFieldsProceed = document.getElementById('important-fields-proceed');
      const customerDeleteModal = document.getElementById('customer-delete-modal');
      const customerDeleteModalText = document.getElementById('customer-delete-modal-text');
      const customerDeleteCancel = document.getElementById('customer-delete-cancel');
      const customerDeleteConfirm = document.getElementById('customer-delete-confirm');
      const openAddressModalButton = document.getElementById('open-address-modal');
      const addressLine1 = document.getElementById('address-line-1');
      const addressLine2 = document.getElementById('address-line-2');
      const addressLine3 = document.getElementById('address-line-3');
      const addressIndicator = document.getElementById('address-indicator');
      const adressePreview = document.getElementById('adresse-preview');
      const adresseBlockInput = document.getElementById('adresseBlock');
      const addressModal = document.getElementById('address-modal');
      const addressFirmaInput = document.getElementById('address-firma');
      const addressZhInput = document.getElementById('address-zh');
      const addressStrasseInput = document.getElementById('address-strasse');
      const addressHausnummerInput = document.getElementById('address-hausnummer');
      const addressPlzInput = document.getElementById('address-plz');
      const addressOrtInput = document.getElementById('address-ort');
      const addressPreviewBlock = document.getElementById('address-preview-block');
      const addressModalCancel = document.getElementById('address-modal-cancel');
      const addressModalApply = document.getElementById('address-modal-apply');
      const openPackageBuilderModalButton = document.getElementById('open-package-builder-modal');
      const singleParamsModal = document.getElementById('single-params-modal');
      const singleParamsPackageWarning = document.getElementById('single-params-package-warning');
      const singleParamsSearchInput = document.getElementById('single-params-search');
      const singleParamsList = document.getElementById('single-params-list');
      const selectedParamsList = document.getElementById('selected-params-list');
      const singleParamsPreviewInput = document.getElementById('single-params-preview');
      const singleParamsCancel = document.getElementById('single-params-cancel');
      const singleParamsApply = document.getElementById('single-params-apply');
      const packageBuilderModal = document.getElementById('package-builder-modal');
      const packageBuilderNameInput = document.getElementById('package-builder-name');
      const packageBuilderSearchInput = document.getElementById('package-builder-search');
      const packageBuilderList = document.getElementById('package-builder-list');
      const packageBuilderSelectedList = document.getElementById('package-builder-selected-list');
      const packageBuilderPreview = document.getElementById('package-builder-preview');
      const packageBuilderCancel = document.getElementById('package-builder-cancel');
      const packageBuilderSave = document.getElementById('package-builder-save');
      const sidebarActionButtons = [
        addProbeButton,
        openBulkProbeModalButton,
        newOrderButton,
        openCustomersModalButton,
        newOrderSameProjectButton,
        draftButton,
        commitButton,
        retryCommitButton,
      ];
      let packages = [];
      let customers = [];
      let activeCustomerSearch = '';
      let activeProbeForGeruchModal = null;
      let activeProbeForNoteModal = null;
      let commitInFlight = false;
      let draftInFlight = false;
      let commitClickLocked = false;
      let commitSlowTimer = null;
      let lastFailedCommitContext = null;
      let activeGebindeTarget = null;
      let activeGebindeTab = 'plastic';
      let pendingImportantFieldsResolver = null;
      let pendingCustomerDeleteResolver = null;
      let pendingCustomerDeleteEntry = null;
      let activeProbeForSingleParamsModal = null;
      let singleParamsCatalog = { version: 1, parameters: [] };
      let singleParamsModalState = {
        toggles: {},
        search: '',
        packageSelectedType: '',
        packageDisplayName: '',
        packageBaseText: '',
        packageBaseToggles: {},
        legacyMergeStatus: '',
        legacyMergeReason: '',
      };
      let packageBuilderState = {
        editId: '',
        name: '',
        search: '',
        toggles: {},
      };
      const SINGLE_PARAM_USAGE_KEY = 'singleParamUsageCountsV1';
      const SINGLE_PARAM_CATALOG_UPDATED_AT_KEY = 'singleParamCatalogUpdatedAtV1';
      const DEFAULT_SINGLE_PARAM_GROUPS = [
        { key: 'AN', label: 'AN', supportsEluateE: true },
        { key: 'SM', label: 'SM', supportsEluateE: true },
        { key: 'Organik', label: 'Organik', supportsEluateE: true },
      ];
      let pendingKuerzelSelection = '';
      let hasLoggedPackageFieldFallback = false;
      const DEFAULT_QUICK_BUTTONS = {
        plastic: ['5L', '3L', '1L', '500mL', '250mL', '250mL + CaCO3', '250mL + NaOH', '100mL', '100mL + NaOH', '30mL', '30mL + HCl', '30mL + HNO3'],
        glass: ['1L', '1L + H2SO4', '500mL', '500mL + H2SO4', '250mL', '250mL Schliff', '250mL Duran', 'HS', 'HS + CuSO4', 'HS + MeOH'],
      };
      const DEFAULT_KUERZEL_PRESETS = ['AD', 'DV', 'LB', 'DH', 'SE', 'JO', 'RS', 'KH'];
      const SAMPLER_OPTIONS = ['SB', 'LW', 'AR', 'JO', 'AD', 'Kunde'];
      let selectedSamplers = [];
      let pendingSamplersSelection = [];

      let appConfig = {
        mode: 'single',
        excelPath: '-',
        writerBackend: '-',
        yearSheetName: '',
        commitAllowed: true,
        uiShowPackagePreview: true,
        uiKuerzelPreset: [...DEFAULT_KUERZEL_PRESETS],
        uiRequiredFields: ['kunde', 'projektName', 'projektnummer'],
        uiRequireAtLeastOneSample: true,
        uiWarnOnly: true,
        uiBlockOnMissing: false,
        uiDefaultEilig: 'ja',
        quickContainerPlastic: [...DEFAULT_QUICK_BUTTONS.plastic],
        quickContainerGlass: [...DEFAULT_QUICK_BUTTONS.glass],
      };

      async function loadConfig() {
        const response = await fetch('/api/config');
        const data = await response.json();
        const cfg = data.config || {};

        appConfig = {
          mode: data.mode ?? cfg.mode ?? 'single',
          excelPath: data.excelPath ?? cfg.excelPath ?? '-',
          writerBackend: cfg.writerBackend || '-',
          yearSheetName: cfg.yearSheetName || '',
          commitAllowed: data.commitAllowed,
          uiShowPackagePreview: cfg.uiShowPackagePreview !== false,
          uiKuerzelPreset: Array.isArray(cfg.uiKuerzelPreset) && cfg.uiKuerzelPreset.length > 0
            ? cfg.uiKuerzelPreset.map((item) => String(item || '').trim()).filter(Boolean)
            : [...DEFAULT_KUERZEL_PRESETS],
          uiRequiredFields: Array.isArray(cfg.uiRequiredFields)
            ? cfg.uiRequiredFields.map((item) => String(item || '').trim()).filter(Boolean)
            : ['kunde', 'projektName', 'projektnummer'],
          uiRequireAtLeastOneSample: cfg.uiRequireAtLeastOneSample !== false,
          uiWarnOnly: cfg.uiWarnOnly !== false,
          uiBlockOnMissing: cfg.uiBlockOnMissing === true,
          uiDefaultEilig: cfg.uiDefaultEilig || 'ja',
          quickContainerPlastic: Array.isArray(cfg.quickContainerPlastic) && cfg.quickContainerPlastic.length > 0
            ? cfg.quickContainerPlastic
            : [...DEFAULT_QUICK_BUTTONS.plastic],
          quickContainerGlass: Array.isArray(cfg.quickContainerGlass) && cfg.quickContainerGlass.length > 0
            ? cfg.quickContainerGlass
            : [...DEFAULT_QUICK_BUTTONS.glass],
        };

        if (appConfig.commitAllowed) {
          commitButton.classList.remove('hidden');
        } else {
          commitButton.classList.add('hidden');
        }
        renderKuerzelPresetButtons();

      }

      async function loadPackages() {
        const [legacyResponse, builderResponse] = await Promise.all([
          fetch('/api/packages', { cache: 'no-store' }),
          fetch('/api/builder-packages', { cache: 'no-store' }),
        ]);
        const legacyData = await legacyResponse.json();
        if (!legacyResponse.ok || !Array.isArray(legacyData)) {
          throw new Error(legacyData.message || 'Pakete konnten nicht geladen werden');
        }
        let builderData = [];
        if (builderResponse.ok) {
          const parsed = await builderResponse.json();
          if (parsed && parsed.ok === true && Array.isArray(parsed.packages)) {
            builderData = parsed.packages;
          }
        }
        const builderPackages = builderData.map((pkg) => {
          const definition = pkg && typeof pkg.definition === 'object' ? pkg.definition : {};
          const toggles = definition && typeof definition.toggles === 'object' ? definition.toggles : {};
          const selection = buildSelectionFromCatalogToggles(singleParamsCatalog, toggles);
          const text = typeof window.buildParameterTextFromSelection === 'function'
            ? window.buildParameterTextFromSelection(selection)
            : buildPreviewTextFromToggles(singleParamsCatalog, toggles);
          const name = String(pkg?.name || pkg?.id || '').trim();
          const firstLine = String(text || '').split('\n').map((line) => line.trim()).filter(Boolean)[0] || '';
          return {
            id: `builder:${String(pkg?.id || '').trim()}`,
            name,
            displayName: `[B] ${name}`,
            shortText: firstLine,
            text: text || '',
            type: 'builder',
            definition,
          };
        }).filter((pkg) => String(pkg.id || '').trim() && String(pkg.name || '').trim());
        packages = [...legacyData, ...builderPackages];
      }

      async function loadSingleParameterCatalog() {
        function normalizeCatalogGroups(rawGroups) {
          const source = Array.isArray(rawGroups) ? rawGroups : [];
          const groups = source
            .map((group) => ({
              key: String(group?.key || '').trim(),
              label: String(group?.label || '').trim(),
              supportsEluateE: group?.supportsEluateE === true,
            }))
            .filter((group) => group.key)
            .map((group) => ({ ...group, label: group.label || group.key }));
          if (groups.length > 0) return groups;
          return DEFAULT_SINGLE_PARAM_GROUPS.map((group) => ({ ...group }));
        }
        function normalizeCatalogForRuntime(catalog) {
          const src = catalog && typeof catalog === 'object' ? catalog : { version: 1, parameters: [] };
          const parameters = Array.isArray(src.parameters) ? src.parameters : [];
          return {
            ...src,
            groups: normalizeCatalogGroups(src.groups),
            parameters: parameters.map((p) => {
              const key = String(p?.key || '').trim();
              const label = String(p?.label || '').trim();
              const labelLongRaw = String(p?.labelLong || '').trim();
              const labelLong = labelLongRaw || ((label && label !== key) ? label : '');
              return {
                ...p,
                key,
                label: label || key,
                labelLong,
              };
            }),
          };
        }
        try {
          const response = await fetch('/api/single-parameter-catalog', { cache: 'no-store' });
          const data = await response.json();
          if (!response.ok || data.ok !== true || !data.catalog || !Array.isArray(data.catalog.parameters)) {
            throw new Error(data?.message || 'Katalog konnte nicht geladen werden');
          }
          const serverUpdatedAt = String(data.updatedAt || data.catalog.updatedAt || '').trim();
          const storedUpdatedAt = String(localStorage.getItem(SINGLE_PARAM_CATALOG_UPDATED_AT_KEY) || '').trim();
          const hasWindowCatalog = window.__singleParamCatalog && Array.isArray(window.__singleParamCatalog.parameters);
          if (hasWindowCatalog && serverUpdatedAt && storedUpdatedAt && serverUpdatedAt === storedUpdatedAt) {
            singleParamsCatalog = normalizeCatalogForRuntime(window.__singleParamCatalog);
            window.__singleParamCatalog = singleParamsCatalog;
            return { changed: false, updatedAt: serverUpdatedAt };
          }
          singleParamsCatalog = normalizeCatalogForRuntime(data.catalog);
          window.__singleParamCatalog = singleParamsCatalog;
          if (serverUpdatedAt) {
            localStorage.setItem(SINGLE_PARAM_CATALOG_UPDATED_AT_KEY, serverUpdatedAt);
          } else {
            localStorage.removeItem(SINGLE_PARAM_CATALOG_UPDATED_AT_KEY);
          }
          return { changed: true, updatedAt: serverUpdatedAt || null };
        } catch (error) {
          const hasWindowCatalog = window.__singleParamCatalog && Array.isArray(window.__singleParamCatalog.parameters);
          if (hasWindowCatalog) {
            singleParamsCatalog = normalizeCatalogForRuntime(window.__singleParamCatalog);
            window.__singleParamCatalog = singleParamsCatalog;
          } else {
            singleParamsCatalog = { version: 1, parameters: [] };
            window.__singleParamCatalog = singleParamsCatalog;
          }
          showToast('error', `Einzelparameter-Katalog: ${error.message}`);
          return { changed: false, updatedAt: null };
        }
      }

      function normalizeCustomerName(value) {
        return String(value || '')
          .trim()
          .replace(/\s+/g, ' ')
          .replace(/,+$/g, '')
          .trim()
          .toLocaleLowerCase('de-DE');
      }

      function normalizeAddressLines(value) {
        return String(value || '')
          .replace(/\r\n?/g, '\n')
          .split('\n')
          .map((line) => line.trim())
          .filter((line) => line !== '');
      }

      function formatAdresseBlock(parts = {}) {
        const firma = String(parts.firma || '').trim();
        const zh = String(parts.zh || '').trim();
        const strasse = String(parts.strasse || '').trim();
        const hausnummer = String(parts.hausnummer || '').trim();
        const plz = String(parts.plz || '').trim();
        const ort = String(parts.ort || '').trim().toUpperCase();
        if (!firma) return '';

        const lines = [firma];
        if (zh) lines.push(`zH ${zh}`);
        const streetLine = [strasse, hausnummer].filter(Boolean).join(' ').trim();
        if (streetLine) lines.push(streetLine);
        const plzOrtLine = [plz, ort].filter(Boolean).join(' ').trim();
        if (plzOrtLine) lines.push(plzOrtLine);
        return lines.join('\n');
      }

      function parseAdresseBlockToFields(value) {
        const lines = normalizeAddressLines(value);
        const out = { firma: '', zh: '', strasse: '', hausnummer: '', plz: '', ort: '' };
        if (lines.length === 0) return out;
        out.firma = lines[0];
        let index = 1;
        if (lines[index] && /^zh\s+/i.test(lines[index])) {
          out.zh = lines[index].replace(/^zh\s+/i, '').trim();
          index += 1;
        }
        if (lines[index]) {
          const streetLine = lines[index];
          const m = streetLine.match(/^(.*?)(\s+\S+)?$/);
          out.strasse = String(m?.[1] || '').trim();
          out.hausnummer = String(m?.[2] || '').trim();
          index += 1;
        }
        if (lines[index]) {
          const plzOrt = lines[index];
          const m = plzOrt.match(/^(\S+)\s+(.+)$/);
          out.plz = String(m?.[1] || '').trim();
          out.ort = String(m?.[2] || plzOrt).trim();
        }
        return out;
      }

      function updateAdressePreviewUi() {
        const rawAddress = String(adresseBlockInput.value || '');
        const lines = normalizeAddressLines(rawAddress);
        const parsed = parseAdresseBlockToFields(rawAddress);
        const hasAddress = rawAddress.trim().length > 0;
        const line1 = hasAddress
          ? (String(parsed.firma || '').trim() || lines[0] || 'Anschrift')
          : 'Anschrift';
        let line2 = '';
        let line3 = '';
        if (hasAddress) {
          line2 = [String(parsed.strasse || '').trim(), String(parsed.hausnummer || '').trim()].filter(Boolean).join(' ').trim();
          line3 = [String(parsed.plz || '').trim(), String(parsed.ort || '').trim()].filter(Boolean).join(' ').trim();
          if (!line2) {
            const fallbackLine2 = lines.find((line, idx) => idx > 0 && !/^zh\s+/i.test(String(line || '').trim()));
            line2 = String(fallbackLine2 || '').trim();
          }
          if (!line3) {
            const fallbackLine3 = lines.find((line, idx) => idx > 1 && String(line || '').trim() !== line2);
            line3 = String(fallbackLine3 || '').trim();
          }
        }
        if (addressLine1) addressLine1.textContent = line1;
        if (addressLine2) addressLine2.textContent = line2;
        if (addressLine3) addressLine3.textContent = line3;
        adressePreview.textContent = lines.length > 0 ? lines[0] : 'Keine Anschrift';
        adressePreview.title = lines.join('\n');
        openAddressModalButton.title = hasAddress ? lines.join('\n') : 'Keine Anschrift';
        if (addressIndicator) {
          addressIndicator.classList.toggle('hidden', !hasAddress);
        }
      }

      function renderCustomerOptions() {
        kundenOptions.innerHTML = '';
        customers.forEach((customer) => {
          const option = document.createElement('option');
          option.value = customer.kunde;
          kundenOptions.appendChild(option);
        });
      }

      function renderCustomerList() {
        const filter = normalizeCustomerName(activeCustomerSearch);
        const entries = customers.filter((entry) => !filter || normalizeCustomerName(entry.kunde).includes(filter));
        customersList.innerHTML = '';
        entries.forEach((entry) => {
          const row = document.createElement('div');
          row.className = 'customer-item-row';
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'secondary customer-item';
          const usageCount = Number(entry.usageCount || 0);
          const meta = usageCount === 1 ? '1 Auftrag' : `${usageCount} Auftraege`;
          const titleEl = document.createElement('strong');
          titleEl.textContent = String(entry.kunde || '');
          const metaEl = document.createElement('span');
          metaEl.textContent = meta || '-';
          btn.appendChild(titleEl);
          btn.appendChild(metaEl);
          btn.addEventListener('click', () => {
            applyCustomerProfile(entry);
            closeCustomersModal();
          });
          row.appendChild(btn);

          const deleteButton = document.createElement('button');
          deleteButton.type = 'button';
          deleteButton.className = 'secondary icon-btn danger';
          deleteButton.title = `Kunde löschen: ${String(entry.kunde || '')}`;
          deleteButton.setAttribute('aria-label', `Kunde löschen: ${String(entry.kunde || '')}`);
          deleteButton.textContent = '✕';
          deleteButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            deleteCustomerEntry(entry);
          });
          row.appendChild(deleteButton);
          customersList.appendChild(row);
        });
        if (entries.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'meta';
          empty.textContent = 'Keine Treffer';
          customersList.appendChild(empty);
        }
      }

      function applyCustomerProfile(selected) {
        if (!selected) return;
        form.kunde.value = String(selected.kunde || '');
        form.ansprechpartner.value = String(selected.ansprechpartner || '');
        form.email.value = String(selected.email || '');
        form.kopfBemerkung.value = String(selected.kopfBemerkung || form.kopfBemerkung.value || '');
        adresseBlockInput.value = String(selected.adresseBlock || '');
        updateAdressePreviewUi();
        updateKopfBemerkungUi();
      }

      async function refreshCustomersFromExcel() {
        customersRefreshFromExcelButton.disabled = true;
        try {
          const response = await fetch('/api/customers/refresh-from-excel', { method: 'POST' });
          const data = await response.json();
          if (!response.ok || !data.ok) {
            throw new Error(data?.message || 'Excel-Refresh fehlgeschlagen');
          }
          await loadCustomers();
          renderCustomerList();
          showToast('success', `Kunden aktualisiert (${data.upserts})`);
        } catch (error) {
          showToast('error', error.message);
        } finally {
          customersRefreshFromExcelButton.disabled = false;
        }
      }

      function openCustomersModal() {
        activeCustomerSearch = '';
        customersSearchInput.value = '';
        renderCustomerList();
        customersModal.classList.remove('hidden');
        setTimeout(() => customersSearchInput.focus(), 0);
      }

      function closeCustomersModal() {
        customersModal.classList.add('hidden');
      }

      function customerDeleteId(entry) {
        const key = String(entry?.key || '').trim();
        if (key) return key;
        return normalizeCustomerName(entry?.kunde || '');
      }

      function openCustomerDeleteModal(entry) {
        pendingCustomerDeleteEntry = entry;
        customerDeleteModalText.textContent = `Kunde wirklich löschen: ${String(entry?.kunde || '')}`;
        customerDeleteModal.classList.remove('hidden');
        setTimeout(() => customerDeleteConfirm.focus(), 0);
        return new Promise((resolve) => {
          pendingCustomerDeleteResolver = resolve;
        });
      }

      function resolveCustomerDeleteModal(confirmed) {
        customerDeleteModal.classList.add('hidden');
        const resolver = pendingCustomerDeleteResolver;
        pendingCustomerDeleteResolver = null;
        pendingCustomerDeleteEntry = null;
        if (resolver) resolver(Boolean(confirmed));
      }

      async function deleteCustomerEntry(entry) {
        const confirmed = await openCustomerDeleteModal(entry);
        if (!confirmed) return;
        const id = customerDeleteId(entry);
        if (!id) {
          showToast('error', 'Kunden-ID fehlt');
          return;
        }
        try {
          const response = await fetch(`/api/customers/${encodeURIComponent(id)}`, { method: 'DELETE' });
          const data = await response.json();
          if (!response.ok || !data.ok) {
            throw new Error(data?.message || 'Löschen fehlgeschlagen');
          }
          await loadCustomers();
          showToast('success', `Kunde gelöscht: ${String(entry.kunde || '')}`);
        } catch (error) {
          showToast('error', error.message);
        }
      }

      function importantFieldLabel(path) {
        const normalized = String(path || '').trim();
        const labels = {
          kunde: 'Kunde',
          projektName: 'Projekt',
          projektnummer: 'Projektnummer',
          ansprechpartner: 'Ansprechpartner',
          email: 'Email',
          kuerzel: 'Kürzel',
          kopfBemerkung: 'Kopfbemerkung',
          adresseBlock: 'Anschrift',
          probenEingangDatum: 'Probeneingangsdatum',
          'proben[0].probenbezeichnung': 'Probe 1: Probenbezeichnung',
          'proben[0].packageId': 'Probe 1: Paket',
          'proben[0].paketKey': 'Probe 1: Paket',
        };
        return labels[normalized] || normalized;
      }

      function parseFieldPath(path) {
        return String(path || '')
          .replace(/\[(\d+)\]/g, '.$1')
          .split('.')
          .map((part) => part.trim())
          .filter(Boolean);
      }

      function resolvePathValue(data, path) {
        const tokens = parseFieldPath(path);
        let cursor = data;
        for (const token of tokens) {
          if (cursor === null || cursor === undefined) return undefined;
          if (/^\d+$/.test(token)) {
            const index = Number(token);
            if (!Array.isArray(cursor) || index >= cursor.length) return undefined;
            cursor = cursor[index];
          } else {
            cursor = cursor[token];
          }
        }
        return cursor;
      }

      function resolveImportantFieldValue(payload, path) {
        const normalizedPath = String(path || '').trim();
        const direct = resolvePathValue(payload, normalizedPath);
        if (!isMissingValue(direct)) {
          return direct;
        }

        // Guard against config drift: older configs use paketKey, UI currently posts packageId.
        if (normalizedPath.includes('.paketKey') || normalizedPath.endsWith('paketKey')) {
          const aliasPath = normalizedPath.replace(/paketKey/g, 'packageId');
          const aliasValue = resolvePathValue(payload, aliasPath);
          if (!isMissingValue(aliasValue)) {
            if (!hasLoggedPackageFieldFallback) {
              console.debug('[ui-required] using packageId fallback for paketKey required field');
              hasLoggedPackageFieldFallback = true;
            }
            return aliasValue;
          }
        }
        if (normalizedPath.includes('.packageId') || normalizedPath.endsWith('packageId')) {
          const aliasPath = normalizedPath.replace(/packageId/g, 'paketKey');
          const aliasValue = resolvePathValue(payload, aliasPath);
          if (!isMissingValue(aliasValue)) {
            return aliasValue;
          }
        }

        return direct;
      }

      function isMissingValue(value) {
        if (value === null || value === undefined) return true;
        if (typeof value === 'string') return value.trim() === '';
        if (Array.isArray(value)) return value.length === 0;
        return false;
      }

      function collectMissingImportantFields(payload) {
        const configured = Array.isArray(appConfig.uiRequiredFields) ? appConfig.uiRequiredFields : [];
        const missing = [];
        configured.forEach((path) => {
          if (!String(path || '').trim()) return;
          const value = resolveImportantFieldValue(payload, path);
          if (isMissingValue(value)) {
            missing.push(importantFieldLabel(path));
          }
        });
        if (appConfig.uiRequireAtLeastOneSample !== false) {
          const sampleCount = Array.isArray(payload.proben) ? payload.proben.length : 0;
          if (sampleCount === 0) {
            missing.push('Mindestens eine Probe');
          }
        }
        return missing;
      }

      function openImportantFieldsModal(missingFields, blockOnMissing) {
        importantFieldsList.innerHTML = '';
        missingFields.forEach((field) => {
          const item = document.createElement('li');
          item.textContent = field;
          importantFieldsList.appendChild(item);
        });
        importantFieldsProceed.classList.toggle('hidden', blockOnMissing);
        importantFieldsModal.classList.remove('hidden');
        setTimeout(() => (blockOnMissing ? importantFieldsCancel : importantFieldsProceed).focus(), 0);
        return new Promise((resolve) => {
          pendingImportantFieldsResolver = resolve;
        });
      }

      function resolveImportantFieldsModal(shouldProceed) {
        importantFieldsModal.classList.add('hidden');
        const resolver = pendingImportantFieldsResolver;
        pendingImportantFieldsResolver = null;
        if (resolver) resolver(Boolean(shouldProceed));
      }

      async function confirmBeforeSend(payload) {
        const missingFields = collectMissingImportantFields(payload);
        if (missingFields.length === 0) {
          return true;
        }
        if (appConfig.uiWarnOnly === false && appConfig.uiBlockOnMissing !== true) {
          return true;
        }
        const allowContinue = await openImportantFieldsModal(missingFields, appConfig.uiBlockOnMissing === true);
        return allowContinue;
      }

      function updateAddressPreviewBlock() {
        const block = formatAdresseBlock({
          firma: addressFirmaInput.value,
          zh: addressZhInput.value,
          strasse: addressStrasseInput.value,
          hausnummer: addressHausnummerInput.value,
          plz: addressPlzInput.value,
          ort: addressOrtInput.value,
        });
        addressPreviewBlock.value = block;
      }

      function openAddressModal() {
        const parsed = parseAdresseBlockToFields(adresseBlockInput.value);
        addressFirmaInput.value = parsed.firma;
        addressZhInput.value = parsed.zh;
        addressStrasseInput.value = parsed.strasse;
        addressHausnummerInput.value = parsed.hausnummer;
        addressPlzInput.value = parsed.plz;
        addressOrtInput.value = parsed.ort;
        updateAddressPreviewBlock();
        addressModal.classList.remove('hidden');
        setTimeout(() => addressFirmaInput.focus(), 0);
      }

      function closeAddressModal() {
        addressModal.classList.add('hidden');
      }

      function applyAddressModal() {
        updateAddressPreviewBlock();
        const block = addressPreviewBlock.value.trim();
        if (!block) {
          showToast('error', 'Firma Name ist erforderlich');
          addressFirmaInput.focus();
          return;
        }
        adresseBlockInput.value = block;
        updateAdressePreviewUi();
        closeAddressModal();
      }

      async function loadCustomers() {
        const response = await fetch('/api/customers');
        const data = await response.json();
        if (!response.ok || !data || !Array.isArray(data.customers)) {
          throw new Error(data?.message || 'Kunden konnten nicht geladen werden');
        }
        customers = [...data.customers].sort((a, b) => {
          const usageDiff = Number(b.usageCount || 0) - Number(a.usageCount || 0);
          if (usageDiff !== 0) return usageDiff;
          return String(a.kunde || '').localeCompare(String(b.kunde || ''), 'de');
        });
        renderCustomerOptions();
        renderCustomerList();
      }

      function autofillCustomerProfile() {
        const selectedName = normalizeCustomerName(form.kunde.value);
        if (!selectedName) return;
        const selected = customers.find((entry) => normalizeCustomerName(entry.kunde) === selectedName);
        if (!selected) return;
        applyCustomerProfile(selected);
      }

      function parseNumberOrUndefined(value) {
        if (value === '') return undefined;
        const parsed = Number(value);
        return Number.isFinite(parsed) ? parsed : undefined;
      }

      function normalizeProbeNameText(value, singleLine = true) {
        const base = String(value || '').replace(/\r\n?/g, '\n').trim();
        if (!singleLine) {
          return base;
        }
        return base.replace(/\n+/g, ' / ').replace(/\s+/g, ' ').trim();
      }

      function getProbeFullName(probeElement) {
        const hiddenInput = probeElement.querySelector('[name="probenbezeichnungFull"]');
        if (hiddenInput && String(hiddenInput.value || '').trim()) {
          return normalizeProbeNameText(hiddenInput.value, false);
        }
        const visibleInput = probeElement.querySelector('[name="probenbezeichnung"]');
        return normalizeProbeNameText(visibleInput?.value || '', false);
      }

      function autoSizeProbeNameInput(input) {
        if (!input) return;
        if (input.tagName === 'TEXTAREA') {
          input.style.height = 'auto';
          const nextHeight = Math.max(30, input.scrollHeight);
          input.style.height = `${nextHeight}px`;
          return;
        }
        const base = normalizeProbeNameText(input.value);
        const chars = Math.max(10, Math.min(56, base.length + 2));
        input.style.width = `${chars}ch`;
      }

      function setProbeNameValue(probeElement, value) {
        const fullValue = normalizeProbeNameText(value, false);
        const visibleInput = probeElement.querySelector('[name="probenbezeichnung"]');
        const hiddenInput = probeElement.querySelector('[name="probenbezeichnungFull"]');
        if (hiddenInput) hiddenInput.value = fullValue;
        visibleInput.value = fullValue;
        visibleInput.title = fullValue;
        autoSizeProbeNameInput(visibleInput);
      }

      function setEiligState(isOn) {
        const value = isOn ? 'ja' : 'nein';
        eiligValueInput.value = value;
        eiligToggle.dataset.value = value;
        eiligToggle.setAttribute('aria-checked', String(isOn));
        eiligToggle.classList.toggle('is-on', isOn);
        const text = eiligToggle.querySelector('.switch-toggle-value');
        if (text) text.textContent = isOn ? 'An' : 'Aus';
      }

      function setProbentransportState(value) {
        const nextValue = value === 'AG' ? 'AG' : 'CUA';
        const isAg = nextValue === 'AG';
        probentransportValueInput.value = nextValue;
        probentransportToggle.dataset.value = nextValue;
        probentransportToggle.setAttribute('aria-checked', String(isAg));
        probentransportToggle.classList.toggle('is-on', isAg);
        const text = probentransportToggle.querySelector('.switch-toggle-value');
        if (text) text.textContent = nextValue;
      }

      function normalizeKuerzelValue(value) {
        return String(value || '').trim().replace(/\s+/g, ' ').toUpperCase();
      }

      function normalizeSamplers(value) {
        const source = Array.isArray(value) ? value : [];
        const seen = new Set();
        const out = [];
        source.forEach((item) => {
          const raw = String(item || '').trim();
          if (!raw) return;
          const normalized = raw.toLowerCase() === 'kunde' ? 'Kunde' : raw.toUpperCase();
          if (!SAMPLER_OPTIONS.includes(normalized) || seen.has(normalized)) return;
          seen.add(normalized);
          out.push(normalized);
        });
        if (out.includes('Kunde')) return ['Kunde'];
        return SAMPLER_OPTIONS.filter((item) => item !== 'Kunde' && out.includes(item));
      }

      function formatSamplersSummary(values) {
        const normalized = normalizeSamplers(values);
        return normalized.join(' + ');
      }

      function updateSamplerUiState() {
        const summary = formatSamplersSummary(selectedSamplers);
        const hasSelection = summary.length > 0;
        if (samplersButtonLabel) {
          samplersButtonLabel.textContent = hasSelection ? `Probenehmer (${summary})` : 'Probenehmer';
        }
        if (openSamplersModalButton) {
          openSamplersModalButton.title = hasSelection ? summary : 'Keine Probenehmer gewählt';
        }
        if (samplersIndicator) {
          samplersIndicator.classList.toggle('hidden', !hasSelection);
        }
      }

      function setSelectedSamplers(nextValues) {
        const next = normalizeSamplers(nextValues);
        selectedSamplers = next;
        updateSamplerUiState();
      }

      function renderSamplersModalButtons() {
        if (!samplersModalButtonsWrap) return;
        const selected = new Set(pendingSamplersSelection);
        samplersModalButtonsWrap.innerHTML = '';
        SAMPLER_OPTIONS.forEach((sampler) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'secondary quick-btn';
          const isActive = selected.has(sampler);
          if (isActive) button.classList.add('is-active');
          button.setAttribute('aria-pressed', String(isActive));
          button.textContent = sampler;
          button.addEventListener('click', () => {
            togglePendingSampler(sampler);
          });
          samplersModalButtonsWrap.appendChild(button);
        });
      }

      function openSamplersModal() {
        pendingSamplersSelection = [...selectedSamplers];
        renderSamplersModalButtons();
        samplersModal.classList.remove('hidden');
      }

      function closeSamplersModal() {
        samplersModal.classList.add('hidden');
      }

      function applySamplersModal() {
        setSelectedSamplers(pendingSamplersSelection);
        closeSamplersModal();
      }

      function togglePendingSampler(sampler) {
        const normalized = String(sampler || '').trim();
        if (!SAMPLER_OPTIONS.includes(normalized)) return;
        if (normalized === 'Kunde') {
          if (pendingSamplersSelection.includes('Kunde')) {
            pendingSamplersSelection = [];
          } else {
            pendingSamplersSelection = ['Kunde'];
          }
          renderSamplersModalButtons();
          return;
        }
        const base = pendingSamplersSelection.filter((item) => item !== 'Kunde');
        if (base.includes(normalized)) {
          pendingSamplersSelection = base.filter((item) => item !== normalized);
          renderSamplersModalButtons();
          return;
        }
        pendingSamplersSelection = [...base, normalized];
        renderSamplersModalButtons();
      }

      function updateKuerzelButtonLabel() {
        const value = normalizeKuerzelValue(form.erfasstKuerzel.value);
        openKuerzelModalButton.textContent = value || 'Kürzel';
      }

      function getKuerzelPresets() {
        const seen = new Set();
        const presets = [];
        const source = Array.isArray(appConfig.uiKuerzelPreset) && appConfig.uiKuerzelPreset.length > 0
          ? appConfig.uiKuerzelPreset
          : DEFAULT_KUERZEL_PRESETS;
        source.forEach((item) => {
          const normalized = normalizeKuerzelValue(item);
          if (!normalized || seen.has(normalized)) return;
          seen.add(normalized);
          presets.push(normalized);
        });
        return presets;
      }

      function setKuerzelValue(nextValue) {
        form.erfasstKuerzel.value = normalizeKuerzelValue(nextValue);
        updateKuerzelButtonLabel();
      }

      function renderKuerzelPresetButtons() {
        const presets = getKuerzelPresets();
        kuerzelButtonsWrap.innerHTML = '';
        presets.forEach((preset) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'secondary kuerzel-preset-btn';
          if (pendingKuerzelSelection === preset) {
            button.classList.add('is-active');
          }
          button.textContent = preset;
          button.addEventListener('click', () => {
            pendingKuerzelSelection = preset;
            kuerzelCustomInput.value = preset;
            renderKuerzelPresetButtons();
          });
          kuerzelButtonsWrap.appendChild(button);
        });
      }

      function openKuerzelModal() {
        pendingKuerzelSelection = normalizeKuerzelValue(form.erfasstKuerzel.value);
        kuerzelCustomInput.value = pendingKuerzelSelection;
        renderKuerzelPresetButtons();
        kuerzelModal.classList.remove('hidden');
        setTimeout(() => kuerzelCustomInput.focus(), 0);
      }

      function closeKuerzelModal() {
        kuerzelModal.classList.add('hidden');
      }

      function applyKuerzelFromCustomInput() {
        const normalized = normalizeKuerzelValue(kuerzelCustomInput.value);
        if (!normalized) {
          showToast('error', 'Bitte Kürzel eingeben');
          kuerzelCustomInput.focus();
          return;
        }
        pendingKuerzelSelection = normalized;
        setKuerzelValue(normalized);
        closeKuerzelModal();
      }

      function resetKuerzelValue() {
        pendingKuerzelSelection = '';
        setKuerzelValue('');
        kuerzelCustomInput.value = '';
        renderKuerzelPresetButtons();
      }

      function updateKopfBemerkungUi() {
        const content = String(form.kopfBemerkung.value || '').trim();
        const hasValue = content.length > 0;
        kopfBemerkungIndicator.classList.toggle('hidden', !hasValue);
        if (kopfBemerkungButtonLabel) {
          kopfBemerkungButtonLabel.textContent = hasValue ? 'Kopfbemerkung ✓' : 'Kopfbemerkung';
        }
        openKopfBemerkungModalButton.title = hasValue ? content : 'Keine Kopfbemerkung';
      }

      function openKopfBemerkungModal() {
        kopfBemerkungModalText.value = String(form.kopfBemerkung.value || '');
        kopfBemerkungModal.classList.remove('hidden');
        setTimeout(() => kopfBemerkungModalText.focus(), 0);
      }

      function closeKopfBemerkungModal() {
        kopfBemerkungModal.classList.add('hidden');
      }

      function applyKopfBemerkungModal() {
        form.kopfBemerkung.value = String(kopfBemerkungModalText.value || '');
        updateKopfBemerkungUi();
        closeKopfBemerkungModal();
      }

      function normalizeGeruchOption(value) {
        const allowed = new Set(['unauffaellig', 'muffig', 'mineralisch', 'loesungsmittelartig', 'faulig', 'sonstiges']);
        return allowed.has(value) ? value : '';
      }

      function geruchLabelFromOption(option) {
        const labels = {
          unauffaellig: 'unauffällig',
          muffig: 'muffig',
          mineralisch: 'mineralisch',
          loesungsmittelartig: 'lösungsmittelartig',
          faulig: 'faulig',
          sonstiges: 'sonstiges',
        };
        return labels[option] || '';
      }

      function buildGeruchSummary(option, sonstiges) {
        const label = geruchLabelFromOption(option);
        if (!label) return '-';
        if (option === 'sonstiges') {
          const details = String(sonstiges || '').trim();
          return details ? `sonstiges: ${details}` : 'sonstiges';
        }
        return label;
      }

      function setProbeGeruchData(probeElement, data = null) {
        const optionInput = probeElement.querySelector('[name="geruchOption"]');
        const sonstigesInput = probeElement.querySelector('[name="geruchSonstiges"]');
        const summaryEl = probeElement.querySelector('[data-geruch-summary]');
        const geruchButton = probeElement.querySelector('[data-action="geruch"]');
        const geruchIndicator = probeElement.querySelector('[data-geruch-indicator]');
        const option = normalizeGeruchOption(String(data?.option || '').trim());
        const sonstiges = option === 'sonstiges' ? String(data?.sonstiges || '').trim() : '';
        const summary = buildGeruchSummary(option, sonstiges);
        optionInput.value = option;
        sonstigesInput.value = sonstiges;
        summaryEl.textContent = summary;
        if (geruchButton) {
          geruchButton.title = summary && summary !== '-' ? summary : 'Geruch wählen';
        }
        if (geruchIndicator) {
          geruchIndicator.classList.toggle('hidden', !option);
        }
      }

      function getProbeGeruchData(probeElement) {
        const option = normalizeGeruchOption(String(probeElement.querySelector('[name="geruchOption"]').value || '').trim());
        const sonstiges = option === 'sonstiges'
          ? String(probeElement.querySelector('[name="geruchSonstiges"]').value || '').trim()
          : '';
        return { option, sonstiges };
      }

      function buildGeruchPayloadValue(option, sonstiges) {
        if (!option) return '';
        if (option === 'sonstiges') {
          const text = String(sonstiges || '').trim();
          return text ? `sonstiges: ${text}` : 'sonstiges';
        }
        return geruchLabelFromOption(option);
      }

      function updateGeruchSonstigesVisibility() {
        const isSonstiges = geruchOptionInput.value === 'sonstiges';
        geruchSonstigesWrap.classList.toggle('hidden', !isSonstiges);
        if (!isSonstiges) {
          geruchSonstigesInput.value = '';
        }
      }

      function openGeruchModalForProbe(probeElement) {
        activeProbeForGeruchModal = probeElement;
        const data = getProbeGeruchData(probeElement);
        geruchOptionInput.value = data.option || 'unauffaellig';
        geruchSonstigesInput.value = data.sonstiges || '';
        updateGeruchSonstigesVisibility();
        geruchModal.classList.remove('hidden');
      }

      function closeGeruchModal() {
        activeProbeForGeruchModal = null;
        geruchModal.classList.add('hidden');
      }

      function applyGeruchModal() {
        if (!activeProbeForGeruchModal) {
          closeGeruchModal();
          return;
        }
        setProbeGeruchData(activeProbeForGeruchModal, {
          option: geruchOptionInput.value,
          sonstiges: geruchSonstigesInput.value,
        });
        closeGeruchModal();
      }

      function updateProbeNoteButton(probeElement) {
        const hiddenInput = probeElement.querySelector('[name="bemerkung"]');
        const noteButton = probeElement.querySelector('[data-action="probe-note"]');
        if (!hiddenInput || !noteButton) return;
        const text = String(hiddenInput.value || '').trim();
        const indicator = noteButton.querySelector('[data-probe-note-indicator]');
        const firstLine = text ? String(text.split(/\r?\n/)[0] || '').trim() : '';
        const preview = text ? (firstLine || 'Bemerkung gesetzt') : 'Keine Bemerkung';
        noteButton.title = preview;
        if (indicator) {
          indicator.classList.toggle('hidden', !text);
        }
      }

      function openProbeNoteModalForProbe(probeElement) {
        activeProbeForNoteModal = probeElement;
        const hiddenInput = probeElement.querySelector('[name="bemerkung"]');
        probeNoteText.value = String(hiddenInput?.value || '');
        probeNoteModal.classList.remove('hidden');
        setTimeout(() => probeNoteText.focus(), 0);
      }

      function closeProbeNoteModal() {
        activeProbeForNoteModal = null;
        probeNoteModal.classList.add('hidden');
      }

      function applyProbeNoteModal() {
        if (!activeProbeForNoteModal) {
          closeProbeNoteModal();
          return;
        }
        const hiddenInput = activeProbeForNoteModal.querySelector('[name="bemerkung"]');
        if (hiddenInput) {
          hiddenInput.value = String(probeNoteText.value || '');
        }
        updateProbeNoteButton(activeProbeForNoteModal);
        closeProbeNoteModal();
      }

      function normalizeQuickLabel(raw) {
        return String(raw || '').trim().replace(/\s+/g, ' ').replace(/\s*\+\s*/g, ' + ');
      }

      function tokenIdFromLabel(label) {
        return normalizeQuickLabel(label).replace(/\s*\+\s*/g, '+').replace(/\s+/g, '-');
      }

      function tokenDisplayFromId(id) {
        return String(id || '').trim().replace(/-/g, ' ').replace(/\+/g, ' + ');
      }

      function normalizeToken(raw) {
        const text = String(raw || '').trim();
        const m = text.match(/^([KG]):(.+)$/i);
        if (!m) return '';
        const prefix = m[1].toUpperCase();
        const id = String(m[2] || '').trim();
        return id ? `${prefix}:${id}` : '';
      }

      function normalizeContainers(data, modeDefault = 'perSample') {
        const source = data && typeof data === 'object' ? data : {};
        const mode = source.mode === 'perOrder' ? 'perOrder' : (source.mode === 'perSample' ? 'perSample' : modeDefault);
        const items = (Array.isArray(source.items) ? source.items : [])
          .map((token) => normalizeToken(token))
          .filter(Boolean);
        return { mode, items, history: [] };
      }

      function parseContainersJsonOrDefault(value, modeDefault = 'perSample') {
        try {
          const parsed = JSON.parse(String(value || '{}'));
          return normalizeContainers(parsed, modeDefault);
        } catch {
          return normalizeContainers(null, modeDefault);
        }
      }

      function getQuickOptions(tabName) {
        const prefix = tabName === 'glass' ? 'G' : 'K';
        const raw = tabName === 'glass'
          ? appConfig.quickContainerGlass
          : appConfig.quickContainerPlastic;
        const seen = new Set();
        const options = [];
        (Array.isArray(raw) ? raw : []).forEach((line) => {
          const id = tokenIdFromLabel(line);
          if (!id || seen.has(id)) return;
          seen.add(id);
          options.push({
            token: `${prefix}:${id}`,
            label: tokenDisplayFromId(id),
          });
        });
        return options;
      }

      function renderContainersSummary(containers) {
        const normalized = normalizeContainers(containers, containers?.mode || 'perSample');
        const counts = new Map();
        normalized.items.forEach((token) => counts.set(token, (counts.get(token) || 0) + 1));
        const renderGroup = (tabName, title) => {
          const options = getQuickOptions(tabName);
          const known = [];
          options.forEach((opt, idx) => {
            if (counts.has(opt.token)) known.push({ token: opt.token, label: opt.label, qty: counts.get(opt.token), order: idx });
          });
          const unknown = [];
          Array.from(counts.entries()).forEach(([token, qty]) => {
            const isGroup = tabName === 'glass' ? token.startsWith('G:') : token.startsWith('K:');
            if (!isGroup || options.some((opt) => opt.token === token)) return;
            unknown.push({ token, label: tokenDisplayFromId(token.slice(2)), qty, order: 10000 + unknown.length });
          });
          const items = [...known, ...unknown].sort((a, b) => a.order - b.order);
          if (!items.length) return '';
          return `${title} (${items.map((it) => (it.qty > 1 ? `${it.qty}x ${it.label}` : it.label)).join('; ')})`;
        };
        const parts = [renderGroup('plastic', 'Kunststoff'), renderGroup('glass', 'Glas')].filter(Boolean);
        return parts.join(' ');
      }

      function setProbeContainersData(probeElement, containers) {
        const normalized = normalizeContainers(containers, 'perSample');
        const summary = renderContainersSummary(normalized);
        const gebindeButton = probeElement.querySelector('[data-action="gebinde"]');
        const gebindeIndicator = probeElement.querySelector('[data-gebinde-indicator]');
        probeElement.querySelector('[name="containersJson"]').value = JSON.stringify(normalized);
        probeElement.querySelector('[data-gebinde-summary]').textContent = summary || '-';
        if (gebindeButton) {
          gebindeButton.title = summary || 'Keine Gebinde';
        }
        if (gebindeIndicator) {
          gebindeIndicator.classList.toggle('hidden', !(summary && summary.trim()));
        }
      }

      function getProbeContainersData(probeElement) {
        return parseContainersJsonOrDefault(probeElement.querySelector('[name="containersJson"]').value, 'perSample');
      }

      function setHeaderContainersData(containers) {
        const normalized = normalizeContainers(containers, 'perOrder');
        form.dataset.headerContainers = JSON.stringify(normalized);
        headerGebindeSummary.textContent = renderContainersSummary(normalized) || '-';
      }

      function getHeaderContainersData() {
        return parseContainersJsonOrDefault(form.dataset.headerContainers || '{}', 'perOrder');
      }

      function renderGebindeQuickButtons(tabName) {
        const options = getQuickOptions(tabName);
        const counts = new Map();
        const items = activeGebindeTarget?.containers?.items || [];
        items.forEach((token) => counts.set(token, (counts.get(token) || 0) + 1));
        gebindeButtonsWrap.innerHTML = '';
        options.forEach((option) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'secondary quick-btn';
          const count = counts.get(option.token) || 0;
          btn.innerHTML = `<span>${option.label}</span>${count > 0 ? `<span class="quick-btn-badge">${count}</span>` : ''}`;
          btn.addEventListener('click', () => {
            activeGebindeTarget.containers.items.push(option.token);
            activeGebindeTarget.containers.history.push(option.token);
            updateGebindeModalPreview();
            renderGebindeQuickButtons(activeGebindeTab);
          });
          gebindeButtonsWrap.appendChild(btn);
        });
      }

      function updateGebindeModalPreview() {
        const containers = activeGebindeTarget?.containers || normalizeContainers(null);
        gebindePreviewInput.value = renderContainersSummary(containers);
      }

      function setGebindeModalTab(tabName) {
        activeGebindeTab = tabName === 'glass' ? 'glass' : 'plastic';
        const tabButtons = Array.from(gebindeModal.querySelectorAll('[data-tab]'));
        tabButtons.forEach((btn) => btn.classList.toggle('is-active', btn.dataset.tab === activeGebindeTab));
        renderGebindeQuickButtons(activeGebindeTab);
        updateGebindeModalPreview();
      }

      function openGebindeModalForProbe(probeElement) {
        gebindeModalTitle.textContent = 'Gebinde auswählen';
        activeGebindeTarget = {
          type: 'probe',
          probeElement,
          containers: normalizeContainers(getProbeContainersData(probeElement), 'perSample'),
        };
        setGebindeModalTab('plastic');
        gebindeModal.classList.remove('hidden');
      }

      function openGebindeModalForHeader() {
        gebindeModalTitle.textContent = 'Gebinde Auftrag auswählen';
        activeGebindeTarget = {
          type: 'header',
          containers: normalizeContainers(getHeaderContainersData(), 'perOrder'),
        };
        setGebindeModalTab('plastic');
        gebindeModal.classList.remove('hidden');
      }

      function closeGebindeModal() {
        activeGebindeTarget = null;
        gebindeModal.classList.add('hidden');
      }

      function applyGebindeModal() {
        if (!activeGebindeTarget) {
          closeGebindeModal();
          return;
        }
        const containers = normalizeContainers(activeGebindeTarget.containers, activeGebindeTarget.type === 'header' ? 'perOrder' : 'perSample');
        if (activeGebindeTarget.type === 'probe' && activeGebindeTarget.probeElement) {
          setProbeContainersData(activeGebindeTarget.probeElement, containers);
        } else if (activeGebindeTarget.type === 'header') {
          setHeaderContainersData(containers);
          updateProbeGebindeUiState();
        }
        closeGebindeModal();
      }

      function updateProbeGebindeUiState() {
        const sameForAll = sameContainersForAllInput.checked;
        openHeaderGebindeModalButton.classList.toggle('hidden', !sameForAll);
        if (sameForAll) {
          headerGebindeSummary.textContent = renderContainersSummary(getHeaderContainersData()) || '-';
        } else {
          headerGebindeSummary.textContent = '-';
        }
        Array.from(probenContainer.querySelectorAll('.probe-row')).forEach((row) => {
          const button = row.querySelector('[data-action="gebinde"]');
          const summary = row.querySelector('[data-gebinde-summary]');
          const indicator = row.querySelector('[data-gebinde-indicator]');
          button.disabled = sameForAll;
          if (sameForAll) {
            summary.textContent = 'wie Auftrag';
            button.title = 'wie Auftrag';
            if (indicator) indicator.classList.remove('hidden');
          } else {
            const containers = getProbeContainersData(row);
            const rendered = renderContainersSummary(containers) || '-';
            summary.textContent = rendered;
            button.title = rendered === '-' ? 'Keine Gebinde' : rendered;
            if (indicator) indicator.classList.toggle('hidden', rendered === '-');
          }
        });
      }

      function isProbeEffectivelyEmpty(probeElement) {
        const name = getProbeFullName(probeElement).trim();
        const material = probeElement.querySelector('[name="material"]').value.trim();
        const packageId = probeElement.querySelector('[name="packageId"]').value.trim();
        const tiefeVolumen = probeElement.querySelector('[name="tiefeVolumen"]').value.trim();
        const gewicht = probeElement.querySelector('[name="gewicht"]').value.trim();
        const geruchData = getProbeGeruchData(probeElement);
        const geruch = buildGeruchPayloadValue(geruchData.option, geruchData.sonstiges);
        const bemerkung = probeElement.querySelector('[name="bemerkung"]').value.trim();
        const gebinde = renderContainersSummary(getProbeContainersData(probeElement));
        return !name && !material && !packageId && !tiefeVolumen && !gewicht && !geruch && !bemerkung && !gebinde;
      }

      function getExistingProbeRows() {
        return Array.from(probenContainer.querySelectorAll('.probe-row'));
      }

      function getNonEmptyProbeCount() {
        return getExistingProbeRows().filter((row) => !isProbeEffectivelyEmpty(row)).length;
      }

      function openBulkProbeModal() {
        const hasExisting = getNonEmptyProbeCount() > 0;
        bulkProbeModeWrap.classList.toggle('hidden', !hasExisting);
        const appendRadio = bulkProbeModeWrap.querySelector('input[value="append"]');
        if (appendRadio) appendRadio.checked = true;
        bulkCopyFromFirstInput.checked = true;
        bulkProbeModal.classList.remove('hidden');
        setTimeout(() => bulkProbeModalText.focus(), 0);
      }

      function closeBulkProbeModal() {
        bulkProbeModal.classList.add('hidden');
      }

      function getBulkInsertMode() {
        const hasExisting = getNonEmptyProbeCount() > 0;
        if (!hasExisting) return 'replace';
        const selected = bulkProbeModeWrap.querySelector('input[name="bulk-probe-mode"]:checked');
        return selected ? selected.value : 'append';
      }

      function getDefaultMaterialForBulkInsert() {
        const firstMaterial = probenContainer.querySelector('.probe-row [name="material"]');
        const value = firstMaterial ? String(firstMaterial.value || '').trim() : '';
        return value || 'Boden';
      }

      function getDefaultPackageForBulkInsert() {
        const firstPackage = probenContainer.querySelector('.probe-row [name="packageId"]');
        return firstPackage && firstPackage.value ? firstPackage.value : '';
      }

      function applyBulkProbeInsert() {
        const names = bulkProbeModalText.value
          .split('\n')
          .map((name) => name.trim())
          .filter(Boolean);

        if (names.length === 0) {
          showToast('error', 'Keine gültigen Probenbezeichnungen gefunden');
          return;
        }

        const mode = getBulkInsertMode();
        const defaultMaterial = getDefaultMaterialForBulkInsert();
        const defaultPackageId = getDefaultPackageForBulkInsert();
        const copyFromFirst = bulkCopyFromFirstInput.checked;
        const firstRow = probenContainer.querySelector('.probe-row');
        const firstRowSeed = firstRow ? {
          material: firstRow.querySelector('[name="material"]').value,
          packageId: firstRow.querySelector('[name="packageId"]').value,
          singleParamsJson: firstRow.querySelector('[name="singleParamsJson"]').value,
          packageAddonsJson: firstRow.querySelector('[name="packageAddonsJson"]').value,
          parameterTextPreview: firstRow.querySelector('[name="parameterTextPreview"]').value,
          tiefeVolumen: firstRow.querySelector('[name="tiefeVolumen"]').value,
          gewicht: firstRow.querySelector('[name="gewicht"]').value,
          geruch: getProbeGeruchData(firstRow),
          bemerkung: firstRow.querySelector('[name="bemerkung"]').value,
          containers: getProbeContainersData(firstRow),
        } : null;
        const allRows = getExistingProbeRows();
        const allRowsAreEmpty = allRows.length > 0 && allRows.every((row) => isProbeEffectivelyEmpty(row));

        if (mode === 'replace' || allRowsAreEmpty) {
          probenContainer.innerHTML = '';
        }

        names.forEach((name) => {
          const base = copyFromFirst && firstRowSeed ? firstRowSeed : {};
          addProbe({
            probenbezeichnung: name,
            material: base.material ?? defaultMaterial ?? 'Boden',
            packageId: base.packageId ?? defaultPackageId ?? '',
            singleParamsJson: base.singleParamsJson ?? '',
            packageAddonsJson: base.packageAddonsJson ?? '',
            parameterTextPreview: base.parameterTextPreview ?? '',
            tiefeVolumen: base.tiefeVolumen ?? '',
            gewicht: base.gewicht ?? '',
            geruch: base.geruch ?? null,
            bemerkung: base.bemerkung ?? '',
            containers: base.containers ?? null,
          });
        });

        bulkProbeModalText.value = '';
        closeBulkProbeModal();
        showToast('success', `${names.length} Proben übernommen`);
      }

      function createClientRequestId() {
        if (window.crypto && typeof window.crypto.randomUUID === 'function') {
          return window.crypto.randomUUID();
        }
        return `req-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      }

      function setCommitFeedback(type, message) {
        commitFeedback.className = 'feedback';
        if (!type || !message) {
          commitFeedback.textContent = '';
          return;
        }
        commitFeedback.classList.add(type);
        commitFeedback.textContent = String(message || '');
      }

      function setAllFormControlsDisabled(isDisabled, allowIds = []) {
        const allowSet = new Set(allowIds);
        for (const element of Array.from(form.elements)) {
          if (allowSet.has(element.id)) continue;
          element.disabled = isDisabled;
        }
      }

      function setSidebarActionsDisabled(isDisabled, allowIds = []) {
        const allowSet = new Set(allowIds);
        sidebarActionButtons.forEach((button) => {
          if (!button) return;
          if (allowSet.has(button.id)) return;
          button.disabled = isDisabled;
        });
      }

      function setCommitUiState(isSaving) {
        commitInFlight = isSaving;
        setButtonLoading(commitButton, isSaving, 'Sende...', 'Commit senden');
        retryCommitButton.disabled = isSaving;
        if (isSaving) {
          draftButton.disabled = true;
          setAllFormControlsDisabled(true, ['commit-btn', 'retry-commit-btn', 'draft-btn']);
          setSidebarActionsDisabled(true, ['commit-btn', 'retry-commit-btn', 'draft-btn']);
        } else if (!draftInFlight) {
          setAllFormControlsDisabled(false);
          setSidebarActionsDisabled(false);
        }
      }

      function setDraftUiState(isSaving) {
        draftInFlight = isSaving;
        setButtonLoading(draftButton, isSaving, 'Lade...', 'Draft senden');
        if (isSaving) {
          commitButton.disabled = true;
          retryCommitButton.disabled = true;
          setAllFormControlsDisabled(true, ['draft-btn', 'commit-btn', 'retry-commit-btn']);
          setSidebarActionsDisabled(true, ['draft-btn', 'commit-btn', 'retry-commit-btn']);
        } else if (!commitInFlight) {
          setAllFormControlsDisabled(false);
          setSidebarActionsDisabled(false);
        }
      }

      function formatSuccessMessage(data) {
        const orderNo = data.orderNo || data.auftragsnummer || '-';
        const first = data.ersteProbennr ?? '-';
        const last = data.letzteProbennr ?? '-';
        const duplicate = data.duplicateIgnored === true ? ' (duplicate ignored)' : '';
        return `Gespeichert${duplicate}: Auftragsnummer ${orderNo}, Probennr ${first} bis ${last}`;
      }

      function clearErrorPanel() {
        errorPanel.classList.add('hidden');
        errorPanel.removeAttribute('open');
        errorDetails.textContent = '';
      }

      function normalizeApiError(data, fallbackMessage = '') {
        const payload = data && typeof data === 'object' ? data : {};
        const userMessage = String(payload.userMessage || payload.message || fallbackMessage || 'Fehler').trim();
        let debug = null;
        if (payload.debug && typeof payload.debug === 'object') {
          debug = payload.debug;
        } else {
          const legacyDebug = {};
          ['where', 'detail', 'line', 'code'].forEach((key) => {
            if (payload[key] === undefined || payload[key] === null) return;
            const value = typeof payload[key] === 'string' ? payload[key].trim() : payload[key];
            if (value === '') return;
            legacyDebug[key] = value;
          });
          if (Object.keys(legacyDebug).length > 0) {
            debug = legacyDebug;
          }
        }
        return { userMessage, debug, payload };
      }

      function showErrorPanel(message, payload = null, debug = null) {
        if (debug && typeof debug === 'object') {
          errorPanel.classList.remove('hidden');
          errorPanel.removeAttribute('open');
          errorDetails.textContent = JSON.stringify({ message, debug }, null, 2);
          return;
        }
        errorPanel.classList.add('hidden');
        errorPanel.removeAttribute('open');
        errorDetails.textContent = '';
      }

      function updateEingangDatumState() {
        const isChecked = probeNochNichtDaInput.checked;
        probenEingangDatumInput.disabled = isChecked;
        if (isChecked) {
          probenEingangDatumInput.value = '';
        } else if (!probenEingangDatumInput.value) {
          probenEingangDatumInput.value = getLocalTodayYmd();
        }
      }

      function getLocalTodayYmd() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      function applyHeaderDefaults() {
        setEiligState(false);
        setProbentransportState('CUA');
        setKuerzelValue('');
        setSelectedSamplers([]);
        adresseBlockInput.value = '';
        updateAdressePreviewUi();
        form.kopfBemerkung.value = '';
        updateKopfBemerkungUi();
        probeNochNichtDaInput.checked = false;
        sameContainersForAllInput.checked = false;
        setHeaderContainersData(null);
        probenahmedatumInput.value = getLocalTodayYmd();
        probenEingangDatumInput.value = getLocalTodayYmd();
        updateEingangDatumState();
        updateProbeGebindeUiState();
      }

      function resetProbeSection() {
        probenContainer.innerHTML = '';
        addProbe();
        bulkProbeModalText.value = '';
        closeBulkProbeModal();
        updateProbeGebindeUiState();
      }

      function resetForNewOrder() {
        form.reset();
        applyHeaderDefaults();
        resetProbeSection();
        lastFailedCommitContext = null;
        retryCommitButton.classList.add('hidden');
        setCommitFeedback('', '');
        clearErrorPanel();
      }

      function resetForNewOrderSameProject() {
        resetProbeSection();
        lastFailedCommitContext = null;
        retryCommitButton.classList.add('hidden');
        setCommitFeedback('', '');
        clearErrorPanel();
      }

      function setPackageText(probeElement) {
        const packageSelect = probeElement.querySelector('[name="packageId"]');
        const parameterTextInput = probeElement.querySelector('[name="parameterTextPreview"]');
        const singleParamsInput = probeElement.querySelector('[name="singleParamsJson"]');
        const singleParamsButton = probeElement.querySelector('[data-action="single-params"]');
        const singleParamsIndicator = probeElement.querySelector('[data-single-params-indicator]');
        const addonToggles = parseSingleParamsTogglesJson(singleParamsInput?.value);
        const hasSingleParams = Object.values(addonToggles || {}).some((toggle) => toggle && toggle.selected === true);
        const selected = packages.find((pkg) => pkg.id === packageSelect.value);
        if (selected) {
          if (selected.type === 'builder') {
            singleParamsModalState.legacyMergeStatus = '';
            singleParamsModalState.legacyMergeReason = '';
            parameterTextInput.value = buildBuilderPackageMergedText(selected, addonToggles);
          } else {
            const baseText = String(selected.text || '').trim();
            const displayName = String(selected.displayName || selected.name || selected.id || '').trim();
            const addonText = buildPreviewTextFromToggles(singleParamsCatalog, addonToggles);
            const legacyPreview = buildLegacyPackageMergedText(baseText, displayName, addonText, addonToggles);
            parameterTextInput.value = legacyPreview.text;
          }
          const previewText = String(parameterTextInput.value || '').trim();
          packageSelect.title = previewText || 'Paket wählen';
          if (singleParamsButton) singleParamsButton.title = previewText || 'Einzelparameter';
          if (singleParamsIndicator) singleParamsIndicator.classList.toggle('hidden', !hasSingleParams);
          return;
        }
        singleParamsModalState.legacyMergeStatus = '';
        singleParamsModalState.legacyMergeReason = '';
        const preview = buildPreviewTextFromToggles(singleParamsCatalog, addonToggles);
        parameterTextInput.value = preview || '';
        const previewText = String(parameterTextInput.value || '').trim();
        packageSelect.title = previewText || 'Paket wählen';
        if (singleParamsButton) singleParamsButton.title = previewText || 'Einzelparameter';
        if (singleParamsIndicator) singleParamsIndicator.classList.toggle('hidden', !hasSingleParams);
      }

      function getCatalogParameters() {
        return Array.isArray(singleParamsCatalog?.parameters) ? singleParamsCatalog.parameters : [];
      }

      function findCatalogParameter(key) {
        return getCatalogParameters().find((p) => String(p?.key || '') === String(key || '')) || null;
      }

      function getParameterDisplay(param, fallbackKey = '') {
        const key = String(param?.key || fallbackKey || '').trim();
        const label = String(param?.label || '').trim();
        const labelLong = String(param?.labelLong || '').trim();
        const name = labelLong || label || key;
        const short = key || label || fallbackKey;
        return { name, short };
      }

      function getPackageById(packageId) {
        const id = String(packageId || '').trim();
        if (!id) return null;
        return packages.find((pkg) => String(pkg?.id || '') === id) || null;
      }

      function getDefaultToggleForParam(param) {
        const allowedLabs = Array.isArray(param?.allowedLabs) ? param.allowedLabs : [];
        const allowedMedia = Array.isArray(param?.allowedMedia) ? param.allowedMedia : [];
        if (allowedLabs.length < 1 || allowedMedia.length < 1) return null;
        const preferredLab = String(param?.defaultLab || '').trim();
        const lab = allowedLabs.includes(preferredLab) ? preferredLab : String(allowedLabs[0] || '').trim();
        if (!lab) return null;
        const preferredMedium = allowedMedia.includes('FS') ? 'FS' : String(allowedMedia[0] || '').trim();
        if (!preferredMedium) return null;
        return {
          selected: true,
          lab,
          media: { [preferredMedium]: true },
        };
      }

      function parseSingleParamsTogglesJson(raw) {
        const text = String(raw || '').trim();
        if (!text) return {};
        try {
          const parsed = JSON.parse(text);
          const toggles = parsed && typeof parsed === 'object' ? parsed.toggles : null;
          return normalizeSingleParamsToggles(toggles);
        } catch (_error) {
          return {};
        }
      }

      function splitTopLevelLegacy(input, delimiterChar) {
        const text = String(input || '');
        const out = [];
        let current = '';
        let depth = 0;
        for (let i = 0; i < text.length; i += 1) {
          const ch = text[i];
          if (ch === '(') depth += 1;
          if (ch === ')' && depth > 0) depth -= 1;
          if (ch === delimiterChar && depth === 0) {
            out.push(current.trim());
            current = '';
            continue;
          }
          current += ch;
        }
        out.push(current.trim());
        return out.filter(Boolean);
      }

      function parseLabeledLegacyLine(line) {
        const raw = String(line || '');
        const idx = raw.indexOf(':');
        if (idx < 0) return null;
        const label = raw.slice(0, idx).trim();
        const value = raw.slice(idx + 1).trim();
        if (!label) return null;
        return { label, value };
      }

      function normalizeLegacyLabel(label) {
        return String(label || '')
          .trim()
          .toLowerCase()
          .replace(/\s+/g, ' ');
      }

      function canonicalLegacyMedium(rawMedium, labelNorm) {
        const source = String(rawMedium || '').trim();
        const key = source.toLowerCase().replace(/\s+/g, '');
        if (key === 'fs') return 'FS';
        if (key === 'h2o') return 'H2O';
        if (labelNorm === 'hb') {
          if (key === '2e' || key === '2:1-eluat' || key === '2:1eluat') return '2e';
          if (key === '10e' || key === '10:1-eluat' || key === '10:1eluat') return '10e';
        } else {
          if (key === '2e') return '2e';
          if (key === '10e') return '10e';
        }
        return source;
      }

      function mediumDisplayLegacy(canonical, labelNorm, original) {
        if (labelNorm === 'hb') {
          if (canonical === '2e') return '2:1-Eluat';
          if (canonical === '10e') return '10:1-Eluat';
        }
        if (canonical === 'FS') return 'FS';
        if (canonical === 'H2O') return 'H2O';
        if (canonical === '2e') return '2e';
        if (canonical === '10e') return '10e';
        return String(original || canonical || '').trim();
      }

      function dedupeLegacyKeepOrder(tokens) {
        const out = [];
        const seen = new Set();
        tokens.forEach((token) => {
          const value = String(token || '').trim();
          if (!value || seen.has(value)) return;
          seen.add(value);
          out.push(value);
        });
        return out;
      }

      function parseLegacyMediumBlocks(value, labelNorm) {
        const rawBlocks = splitTopLevelLegacy(value, ';');
        const blocks = [];
        for (const rawBlock of rawBlocks) {
          const idx = rawBlock.indexOf(':');
          if (idx < 0) return { ok: false, reason: `medium_block_missing_colon:${rawBlock}` };
          const medium = rawBlock.slice(0, idx).trim();
          const content = rawBlock.slice(idx + 1).trim();
          if (!medium) return { ok: false, reason: 'medium_label_empty' };
          blocks.push({
            originalMedium: medium,
            canonical: canonicalLegacyMedium(medium, labelNorm),
            tokens: splitTopLevelLegacy(content, ','),
          });
        }
        return { ok: true, blocks };
      }

      function tryMergeLegacyPackagePreview(baseText, addonText) {
        const base = String(baseText || '').trim();
        const addon = String(addonText || '').trim();
        if (!addon) return { ok: true, mergedText: base, reason: null };

        const baseLines = base ? base.split(/\r?\n/) : [];
        const addonLines = addon.split(/\r?\n/).map((x) => String(x || '').trim()).filter(Boolean);
        const parsedBase = baseLines.map((line, idx) => {
          const parsed = parseLabeledLegacyLine(line);
          if (!parsed) return { raw: line, index: idx, label: null, value: null, labelNorm: null };
          return {
            raw: line,
            index: idx,
            label: parsed.label,
            value: parsed.value,
            labelNorm: normalizeLegacyLabel(parsed.label),
          };
        });

        for (const addonLine of addonLines) {
          const parsedAddon = parseLabeledLegacyLine(addonLine);
          if (!parsedAddon) {
            return { ok: false, mergedText: base, reason: `addon_line_missing_colon:${addonLine}` };
          }
          const labelNorm = normalizeLegacyLabel(parsedAddon.label);
          const baseMatch = parsedBase.find((entry) => entry.labelNorm === labelNorm);
          if (!baseMatch) {
            const appended = `${parsedAddon.label}: ${parsedAddon.value}`.trim();
            baseLines.push(appended);
            parsedBase.push({
              raw: appended,
              index: baseLines.length - 1,
              label: parsedAddon.label,
              value: parsedAddon.value,
              labelNorm,
            });
            continue;
          }

          let mergedValue = '';
          if (labelNorm === 'pv') {
            mergedValue = dedupeLegacyKeepOrder([
              ...splitTopLevelLegacy(baseMatch.value, ','),
              ...splitTopLevelLegacy(parsedAddon.value, ','),
            ]).join(', ');
          } else if (labelNorm === 'vor ort' || labelNorm === 'vor-ort') {
            mergedValue = dedupeLegacyKeepOrder([
              ...String(baseMatch.value || '').split(','),
              ...String(parsedAddon.value || '').split(','),
            ]).join(', ');
          } else {
            const parsedBaseBlocks = parseLegacyMediumBlocks(baseMatch.value, labelNorm);
            if (!parsedBaseBlocks.ok) return { ok: false, mergedText: base, reason: parsedBaseBlocks.reason };
            const parsedAddonBlocks = parseLegacyMediumBlocks(parsedAddon.value, labelNorm);
            if (!parsedAddonBlocks.ok) return { ok: false, mergedText: base, reason: parsedAddonBlocks.reason };
            const byCanonical = new Map();
            const order = [];
            parsedBaseBlocks.blocks.forEach((block) => {
              byCanonical.set(block.canonical, {
                originalMedium: block.originalMedium,
                tokens: [...block.tokens],
              });
              order.push(block.canonical);
            });
            parsedAddonBlocks.blocks.forEach((block) => {
              const existing = byCanonical.get(block.canonical);
              if (existing) {
                existing.tokens = dedupeLegacyKeepOrder([...existing.tokens, ...block.tokens]);
                return;
              }
              byCanonical.set(block.canonical, {
                originalMedium: block.originalMedium,
                tokens: [...block.tokens],
              });
              order.push(block.canonical);
            });
            mergedValue = order
              .map((canonical) => {
                const block = byCanonical.get(canonical);
                if (!block) return '';
                const mediumLabel = mediumDisplayLegacy(canonical, labelNorm, block.originalMedium);
                return `${mediumLabel}: ${dedupeLegacyKeepOrder(block.tokens).join(', ')}`.trim();
              })
              .filter(Boolean)
              .join('; ');
          }

          const newLine = `${baseMatch.label}: ${mergedValue}`.trim();
          baseLines[baseMatch.index] = newLine;
          baseMatch.raw = newLine;
          baseMatch.value = mergedValue;
        }

        return { ok: true, mergedText: baseLines.join('\n').trim(), reason: null };
      }

      function stripExistingPktLines(text) {
        if (!text) return '';
        const lines = String(text).split(/\r?\n/);
        const out = lines.filter((line) => !String(line).trimStart().toUpperCase().startsWith('PKT:'));
        return out.join('\n').trim();
      }

      function buildPktAddonSuffixFromToggles(catalog, toggles) {
        if (!toggles || typeof toggles !== 'object') return '';
        const params = Array.isArray(catalog?.parameters) ? catalog.parameters : [];
        const byKey = new Map(params.map((p) => [String(p?.key || '').trim(), p]));
        const labels = [];
        Object.entries(toggles).forEach(([rawKey, toggle]) => {
          const key = String(rawKey || '').trim();
          if (!key || !toggle || toggle.selected !== true) return;
          const param = byKey.get(key);
          const labelLong = String(param?.labelLong || '').trim();
          labels.push(labelLong || key);
        });
        const unique = Array.from(new Set(labels));
        unique.sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }));
        if (unique.length < 1) return '';
        return `+${unique.join(', +')}`;
      }

      function extractLegacyManualAddonLines(addonText) {
        const source = String(addonText || '').replace(/\r\n?/g, '\n');
        if (!source) return [];
        return source
          .split('\n')
          .map((line) => String(line || '').trim())
          .filter((line) => line && /^[^:]+:/.test(line))
          .filter((line) => !/^(PKT|PV|VOR\s*ORT)\s*:/i.test(line));
      }

      function buildLegacyManualBlock(packageDisplayName, addonSuffix, addonText) {
        const packageName = String(packageDisplayName || '').trim();
        const suffix = String(addonSuffix || '').trim();
        const manualLines = extractLegacyManualAddonLines(addonText);
        const pktLine = `PKT: ${[packageName, suffix].filter(Boolean).join(' ')}`.trim();
        return [
          'MANUELL (Legacy Paket): Addons bitte in Excel in die Paketzeilen übernehmen.',
          pktLine,
          ...manualLines,
        ].join('\n');
      }

      function mergeBuilderPackageAddonToggles(baseToggles, addonToggles) {
        const merged = normalizeSingleParamsToggles(baseToggles || {});
        const addons = normalizeSingleParamsToggles(addonToggles || {});
        Object.entries(addons).forEach(([key, addonToggle]) => {
          const param = findCatalogParameter(key);
          if (!param || !addonToggle || addonToggle.selected !== true) return;
          const base = merged[key];
          if (!base || base.selected !== true) {
            merged[key] = addonToggle;
            return;
          }
          const mergedMedia = {};
          const baseMedia = base.media && typeof base.media === 'object' ? base.media : {};
          const addonMedia = addonToggle.media && typeof addonToggle.media === 'object' ? addonToggle.media : {};
          Object.entries(baseMedia).forEach(([medium, enabled]) => {
            if (enabled === true) mergedMedia[medium] = true;
          });
          Object.entries(addonMedia).forEach(([medium, enabled]) => {
            if (enabled === true) mergedMedia[medium] = true;
          });
          const mergedVorOrt = base.vorOrt === true || addonToggle.vorOrt === true;
          merged[key] = {
            ...base,
            selected: true,
            lab: String(base.lab || '').trim(),
            media: mergedVorOrt ? {} : mergedMedia,
            vorOrt: mergedVorOrt,
          };
        });
        return merged;
      }

      function buildBuilderPackageMergedText(packageEntry, addonToggles) {
        const definition = packageEntry && typeof packageEntry.definition === 'object' ? packageEntry.definition : {};
        const baseToggles = definition && typeof definition.toggles === 'object' ? definition.toggles : {};
        const mergedToggles = mergeBuilderPackageAddonToggles(baseToggles, addonToggles);
        const built = buildPreviewTextFromToggles(singleParamsCatalog, mergedToggles);
        const suffix = buildPktAddonSuffixFromToggles(singleParamsCatalog, addonToggles);
        const packageName = String(packageEntry?.name || packageEntry?.displayName || packageEntry?.id || '').trim();
        const pktHeader = packageName ? `PKT: ${packageName}${suffix}` : '';
        if (!pktHeader) return built;
        if (!built) return pktHeader;
        return `${pktHeader}\n${built}`;
      }

      function buildLegacyPackageMergedText(baseText, packageDisplayName, addonText, addonToggles) {
        const base = stripExistingPktLines(baseText);
        const packageName = String(packageDisplayName || '').trim();
        const suffix = buildPktAddonSuffixFromToggles(singleParamsCatalog, addonToggles);
        const addon = String(addonText || '').trim();
        const hasAddons = Boolean(suffix);
        const pktHeader = packageName ? `PKT: ${packageName}` : '';
        const baseBody = [pktHeader, base].filter(Boolean).join('\n');
        const manualBlock = hasAddons
          ? buildLegacyManualBlock(packageName, suffix, addon)
          : '';
        return {
          text: manualBlock
            ? [baseBody, manualBlock].filter(Boolean).join('\n\n')
            : baseBody,
          legacyMergeStatus: hasAddons ? 'appended' : '',
          legacyMergeReason: hasAddons ? 'legacy_manual_block' : '',
        };
      }

      function findCatalogGroup(groupKey) {
        const target = String(groupKey || '').trim();
        if (!target) return null;
        const groups = normalizeCatalogGroupsRuntime(singleParamsCatalog);
        return groups.find((group) => String(group.key || '').trim() === target) || null;
      }

      function loadUsageCounts() {
        try {
          const raw = localStorage.getItem(SINGLE_PARAM_USAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') return {};
          return parsed;
        } catch (_error) {
          return {};
        }
      }

      function saveUsageCounts(obj) {
        try {
          localStorage.setItem(SINGLE_PARAM_USAGE_KEY, JSON.stringify(obj || {}));
        } catch (_error) {
          // ignore storage errors
        }
      }

      function incrementUsageCountsForSelected(toggles) {
        const usage = loadUsageCounts();
        const source = toggles && typeof toggles === 'object' ? toggles : {};
        Object.entries(source).forEach(([key, value]) => {
          if (value && value.selected === true) {
            usage[key] = Number(usage[key] || 0) + 1;
          }
        });
        saveUsageCounts(usage);
      }

      function normalizeSingleParamsToggles(raw) {
        const source = raw && typeof raw === 'object' ? raw : {};
        const out = {};
        Object.entries(source).forEach(([key, value]) => {
          if (!value || value.selected !== true) return;
          const param = findCatalogParameter(key);
          if (!param) return;
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
          if (allowedLabs.length === 0 || allowedMedia.length === 0) return;
          const lab = allowedLabs.includes(String(value.lab || '').trim())
            ? String(value.lab || '').trim()
            : (allowedLabs.includes(String(param.defaultLab || '').trim())
              ? String(param.defaultLab || '').trim()
              : allowedLabs[0]);
          const mediaSource = value.media && typeof value.media === 'object' ? value.media : {};
          const media = {};
          allowedMedia.forEach((medium) => {
            if (allowedMedia.includes(medium) && mediaSource[medium] === true) {
              media[medium] = true;
            }
          });
          out[key] = {
            selected: true,
            lab,
            media,
            vorOrt: param.allowVorOrt === true && value.vorOrt === true,
          };
        });
        return out;
      }

      function createGroupedMediumBucket() {
        return {
          plain: [],
          groups: {},
          groupEFlags: {},
        };
      }

      function normalizeCatalogGroupsRuntime(catalog) {
        const source = Array.isArray(catalog?.groups) ? catalog.groups : [];
        const groups = source
          .map((group) => ({
            key: String(group?.key || '').trim(),
            label: String(group?.label || '').trim(),
            supportsEluateE: group?.supportsEluateE === true,
          }))
          .filter((group) => group.key)
          .map((group) => ({ ...group, label: group.label || group.key }));
        if (groups.length > 0) return groups;
        return DEFAULT_SINGLE_PARAM_GROUPS.map((group) => ({ ...group }));
      }

      function ensureBucketGroup(bucket, groupKey) {
        if (!bucket.groups[groupKey]) bucket.groups[groupKey] = [];
        if (bucket.groupEFlags[groupKey] !== true) bucket.groupEFlags[groupKey] = false;
      }

      function dedupeSortedTokens(values) {
        return Array.from(new Set((Array.isArray(values) ? values : []).map((v) => String(v || '').trim()).filter(Boolean)))
          .sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }));
      }

      function buildGroupedMediumItems(bucket, medium, groupDefs) {
        const isEluateMedium = medium === '2e' || medium === '10e';
        const parts = [];
        groupDefs.forEach((groupDef) => {
          const groupKey = String(groupDef?.key || '').trim();
          if (!groupKey) return;
          const members = dedupeSortedTokens(bucket.groups[groupKey]);
          if (members.length === 0) return;
          let functionName = String(groupDef?.label || groupKey).trim() || groupKey;
          if (isEluateMedium && groupDef.supportsEluateE === true && bucket.groupEFlags[groupKey] === true) {
            functionName = `e${functionName}`;
          }
          parts.push(`${functionName}(${members.join(', ')})`);
        });
        parts.push(...dedupeSortedTokens(bucket.plain));
        return parts;
      }

      function formatMediumLabel(lab, mediumKey) {
        if (lab === 'HB') {
          if (mediumKey === '2e') return '2:1-Eluat';
          if (mediumKey === '10e') return '10:1-Eluat';
        }
        return mediumKey;
      }

      function buildSelectionFromCatalogToggles(catalog, togglesState) {
        const params = Array.isArray(catalog?.parameters) ? catalog.parameters : [];
        const byKey = new Map(params.map((p) => [String(p?.key || ''), p]));
        const groupDefs = normalizeCatalogGroupsRuntime(catalog);
        const groupByKey = new Map(groupDefs.map((group) => [group.key, group]));
        const labBuckets = {
          EMD: { FS: createGroupedMediumBucket(), H2O: createGroupedMediumBucket(), '2e': createGroupedMediumBucket(), '10e': createGroupedMediumBucket() },
          HB: { FS: createGroupedMediumBucket(), H2O: createGroupedMediumBucket(), '2e': createGroupedMediumBucket(), '10e': createGroupedMediumBucket() },
        };
        const pvSeen = new Set();
        const pvEluate = [];
        const vorOrtTokens = [];

        Object.entries(togglesState || {}).forEach(([key, toggle]) => {
          if (!toggle || toggle.selected !== true) return;
          const param = byKey.get(key);
          if (!param) return;
          const keyToken = String(param.key || key).trim() || String(key || '').trim();
          if (toggle.vorOrt === true) {
            vorOrtTokens.push(keyToken);
            return;
          }
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
          if (allowedLabs.length === 0 || allowedMedia.length === 0) return;
          const lab = allowedLabs.includes(String(toggle.lab || '').trim())
            ? String(toggle.lab || '').trim()
            : (allowedLabs.includes(String(param.defaultLab || '').trim())
              ? String(param.defaultLab || '').trim()
              : allowedLabs[0]);
          if (lab !== 'EMD' && lab !== 'HB') return;
          const fg = String(param.functionGroup || '').trim();
          ['FS', 'H2O', '2e', '10e'].forEach((medium) => {
            if (!allowedMedia.includes(medium)) return;
            if (!(toggle.media && toggle.media[medium] === true)) return;
            const isEluateMedium = medium === '2e' || medium === '10e';
            const wantsE = isEluateMedium && param.eluatePrefixE === true;
            const bucket = labBuckets[lab][medium];
            let groupDef = fg ? (groupByKey.get(fg) || null) : null;
            if (!groupDef && fg) {
              groupDef = { key: fg, label: fg, supportsEluateE: true };
              groupDefs.push(groupDef);
              groupByKey.set(fg, groupDef);
            }
            if (groupDef) {
              ensureBucketGroup(bucket, groupDef.key);
              bucket.groups[groupDef.key].push(keyToken);
              if (wantsE) bucket.groupEFlags[groupDef.key] = true;
            } else {
              bucket.plain.push(wantsE ? `e${keyToken}` : keyToken);
            }
            const requiresPv = Array.isArray(param.requiresPv) ? param.requiresPv : [];
            if (isEluateMedium && requiresPv.includes(medium)) {
              const site = lab === 'EMD' ? 'E' : 'B';
              const pvKey = `${site}:${medium}`;
              if (!pvSeen.has(pvKey)) {
                pvSeen.add(pvKey);
                pvEluate.push({ site, ratio: medium });
              }
            }
          });
        });

        const labs = [];
        ['EMD', 'HB'].forEach((lab) => {
          const media = [];
          ['FS', 'H2O', '2e', '10e'].forEach((medium) => {
            const items = buildGroupedMediumItems(labBuckets[lab][medium], medium, groupDefs);
            if (items.length > 0) media.push({ medium, items });
          });
          if (media.length > 0) labs.push({ lab, media });
        });
        const selection = { labs, extern: [] };
        const dedupedVorOrt = dedupeSortedTokens(vorOrtTokens);
        if (dedupedVorOrt.length > 0) selection.vorOrt = dedupedVorOrt;
        if (pvEluate.length > 0) selection.pv = { ts: false, eluate: pvEluate };
        return selection;
      }

      function buildPreviewTextFromToggles(catalog, toggles) {
        const mediaOrder = ['FS', 'H2O', '2e', '10e'];
        const ratioOrder = { '2e': 0, '10e': 1 };
        const params = Array.isArray(catalog?.parameters) ? catalog.parameters : [];
        const byKey = new Map(params.map((p) => [String(p?.key || '').trim(), p]));
        const groupDefs = normalizeCatalogGroupsRuntime(catalog);
        const groupByKey = new Map(groupDefs.map((group) => [group.key, group]));
        function createLabBucket() {
          return {
            FS: createGroupedMediumBucket(),
            H2O: createGroupedMediumBucket(),
            '2e': createGroupedMediumBucket(),
            '10e': createGroupedMediumBucket(),
            other: {},
          };
        }
        const labs = { EMD: createLabBucket(), HB: createLabBucket() };
        const externLabs = new Map();
        const pvBySite = { E: { tokens: new Set(), ratios: new Set() }, B: { tokens: new Set(), ratios: new Set() } };
        const vorOrtTokens = [];

        Object.entries(toggles || {}).forEach(([key, toggle]) => {
          if (!toggle || toggle.selected !== true) return;
          const param = byKey.get(String(key || '').trim());
          if (!param) return;
          const keyToken = String(param.key || key).trim() || String(key || '').trim();
          if (toggle.vorOrt === true) {
            vorOrtTokens.push(keyToken);
            return;
          }
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
          if (allowedLabs.length === 0 || allowedMedia.length === 0) return;
          const lab = allowedLabs.includes(String(toggle.lab || '').trim())
            ? String(toggle.lab || '').trim()
            : (allowedLabs.includes(String(param.defaultLab || '').trim())
              ? String(param.defaultLab || '').trim()
              : String(allowedLabs[0] || '').trim());
          if (!lab) return;
          const labBucket = lab === 'EMD' || lab === 'HB'
            ? labs[lab]
            : (externLabs.get(lab) || createLabBucket());
          const fg = String(param.functionGroup || '').trim();
          const mediaSource = toggle.media && typeof toggle.media === 'object' ? toggle.media : {};
          Object.entries(mediaSource).forEach(([mediumRaw, enabled]) => {
            if (enabled !== true) return;
            const medium = String(mediumRaw || '').trim();
            if (!medium || !allowedMedia.includes(medium)) return;
            const isEluateMedium = medium === '2e' || medium === '10e';
            const wantsE = isEluateMedium && param.eluatePrefixE === true;
            const bucket = mediaOrder.includes(medium)
              ? labBucket[medium]
              : (labBucket.other[medium] || (labBucket.other[medium] = createGroupedMediumBucket()));
            let groupDef = fg ? (groupByKey.get(fg) || null) : null;
            if (!groupDef && fg) {
              groupDef = { key: fg, label: fg, supportsEluateE: true };
              groupDefs.push(groupDef);
              groupByKey.set(fg, groupDef);
            }
            if (groupDef) {
              ensureBucketGroup(bucket, groupDef.key);
              bucket.groups[groupDef.key].push(keyToken);
              if (wantsE) bucket.groupEFlags[groupDef.key] = true;
            } else {
              bucket.plain.push(wantsE ? `e${keyToken}` : keyToken);
            }
            if (param.pvFlag === true && (lab === 'EMD' || lab === 'HB')) {
              const pvSite = lab === 'EMD' ? 'E' : 'B';
              pvBySite[pvSite].tokens.add(keyToken);
            }
            if (isEluateMedium && (lab === 'EMD' || lab === 'HB')) {
              const site = lab === 'EMD' ? 'E' : 'B';
              pvBySite[site].ratios.add(medium);
            }
          });
          if (lab !== 'EMD' && lab !== 'HB') {
            externLabs.set(lab, labBucket);
          }
        });

        function renderLabLine(labName, bucket) {
          const blocks = [];
          mediaOrder.forEach((medium) => {
            const parts = buildGroupedMediumItems(bucket[medium], medium, groupDefs);
            if (parts.length > 0) {
              const mediumLabel = formatMediumLabel(labName, medium);
              blocks.push(`${mediumLabel}: ${parts.join(', ')}`);
            }
          });
          Object.keys(bucket.other || {})
            .sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }))
            .forEach((medium) => {
              const parts = buildGroupedMediumItems(bucket.other[medium], medium, groupDefs);
              if (parts.length > 0) {
                const mediumLabel = formatMediumLabel(labName, medium);
                blocks.push(`${mediumLabel}: ${parts.join(', ')}`);
              }
            });
          if (blocks.length === 0) return '';
          return `${labName}: ${blocks.join('; ')}`;
        }

        const pvSiteTokens = [];
        ['E', 'B'].forEach((site) => {
          const tokens = Array.from(pvBySite[site].tokens).sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }));
          const ratios = Array.from(pvBySite[site].ratios).sort((a, b) => (ratioOrder[a] ?? 99) - (ratioOrder[b] ?? 99));
          const members = [...tokens, ...ratios];
          if (members.length > 0) {
            pvSiteTokens.push(`${site}(${members.join(', ')})`);
          }
        });

        const lines = [];
        const vorOrt = dedupeSortedTokens(vorOrtTokens);
        if (vorOrt.length > 0) {
          lines.push(`vor Ort: ${vorOrt.join(', ')}`);
        }
        if (pvSiteTokens.length > 0) {
          lines.push(`PV: ${pvSiteTokens.join(', ')}`);
        }
        const emdLine = renderLabLine('EMD', labs.EMD);
        if (emdLine) lines.push(emdLine);
        const hbLine = renderLabLine('HB', labs.HB);
        if (hbLine) lines.push(hbLine);
        Array.from(externLabs.keys())
          .sort((a, b) => a.localeCompare(b, 'de', { sensitivity: 'base' }))
          .forEach((labName) => {
            const line = renderLabLine(labName, externLabs.get(labName));
            if (line) lines.push(line);
          });
        return lines.join('\n');
      }

      function updateSingleParamsModalPreview() {
        let preview = '';
        if (singleParamsModalState.packageSelectedType === 'builder') {
          singleParamsModalState.legacyMergeStatus = '';
          singleParamsModalState.legacyMergeReason = '';
          const mergedToggles = mergeBuilderPackageAddonToggles(
            singleParamsModalState.packageBaseToggles,
            singleParamsModalState.toggles,
          );
          const mergedText = buildPreviewTextFromToggles(singleParamsCatalog, mergedToggles);
          const suffix = buildPktAddonSuffixFromToggles(singleParamsCatalog, singleParamsModalState.toggles);
          const pktHeader = singleParamsModalState.packageDisplayName ? `PKT: ${singleParamsModalState.packageDisplayName}${suffix}` : '';
          if (pktHeader && mergedText) {
            preview = `${pktHeader}\n${mergedText}`;
          } else {
            preview = pktHeader || mergedText;
          }
        } else if (singleParamsModalState.packageSelectedType === 'legacy') {
          const addonText = buildPreviewTextFromToggles(singleParamsCatalog, singleParamsModalState.toggles);
          const legacyPreview = buildLegacyPackageMergedText(
            singleParamsModalState.packageBaseText,
            singleParamsModalState.packageDisplayName,
            addonText,
            singleParamsModalState.toggles,
          );
          preview = legacyPreview.text;
          singleParamsModalState.legacyMergeStatus = legacyPreview.legacyMergeStatus;
          singleParamsModalState.legacyMergeReason = legacyPreview.legacyMergeReason;
        } else {
          singleParamsModalState.legacyMergeStatus = '';
          singleParamsModalState.legacyMergeReason = '';
          preview = buildPreviewTextFromToggles(singleParamsCatalog, singleParamsModalState.toggles);
        }
        const escapeHtml = (value) => String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
        const html = String(preview || '')
          .split('\n')
          .map((line) => {
            const match = line.match(/^([^:]+:)(.*)$/);
            if (!match) return `<div>${escapeHtml(line)}</div>`;
            const head = escapeHtml(match[1]);
            const tail = escapeHtml(match[2] || '');
            return `<div><strong>${head}</strong>${tail}</div>`;
          })
          .join('');
        updateSingleParamsPackageWarning();
        singleParamsPreviewInput.innerHTML = html;
        return preview;
      }

      function updateSingleParamsPackageWarning() {
        if (!singleParamsModalState.packageSelectedType) {
          singleParamsPackageWarning.classList.add('hidden');
          singleParamsPackageWarning.style.color = '';
          singleParamsPackageWarning.innerHTML = '';
          return;
        }
        singleParamsPackageWarning.classList.remove('hidden');
        if (singleParamsModalState.packageSelectedType === 'builder') {
          singleParamsPackageWarning.style.color = '#166534';
          singleParamsPackageWarning.textContent = 'Builder Paket. Addons werden strukturiert gemerged und einsortiert.';
          return;
        }
        singleParamsPackageWarning.style.color = '#b45309';
        singleParamsPackageWarning.textContent = 'Legacy Paket. Addons müssen manuell übernommen werden.';
      }

      function getSelectedParamKeys() {
        return Object.keys(singleParamsModalState.toggles || {}).filter((key) => singleParamsModalState.toggles[key]?.selected === true);
      }

      function toggleSingleParamSelection(key) {
        const param = findCatalogParameter(key);
        if (!param) return;
        if (singleParamsModalState.toggles[key]?.selected === true) {
          delete singleParamsModalState.toggles[key];
        } else {
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const lab = allowedLabs.includes(String(param.defaultLab || '').trim())
            ? String(param.defaultLab || '').trim()
            : (allowedLabs[0] || '');
          singleParamsModalState.toggles[key] = {
            selected: true,
            lab,
            media: {},
            vorOrt: false,
          };
        }
        renderSingleParamsModal();
      }

      function toggleSingleParamVorOrt(key) {
        const param = findCatalogParameter(key);
        if (!param || param.allowVorOrt !== true) return;
        if (!singleParamsModalState.toggles[key]?.selected) return;
        singleParamsModalState.toggles[key].vorOrt = singleParamsModalState.toggles[key].vorOrt !== true;
        renderSingleParamsModal();
      }

      function setSingleParamLab(key, lab) {
        const param = findCatalogParameter(key);
        if (!param) return;
        const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
        if (!allowedLabs.includes(lab)) return;
        if (!singleParamsModalState.toggles[key]?.selected) return;
        if (singleParamsModalState.toggles[key].vorOrt === true) return;
        singleParamsModalState.toggles[key].lab = lab;
        renderSingleParamsModal();
      }

      function toggleSingleParamMedium(key, medium) {
        const param = findCatalogParameter(key);
        if (!param) return;
        const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
        if (!allowedMedia.includes(medium)) return;
        if (!singleParamsModalState.toggles[key]?.selected) return;
        if (singleParamsModalState.toggles[key].vorOrt === true) return;
        const media = singleParamsModalState.toggles[key].media || {};
        if (media[medium] === true) {
          delete media[medium];
        } else {
          media[medium] = true;
        }
        singleParamsModalState.toggles[key].media = media;
        renderSingleParamsModal();
      }

      function renderSingleParamsList() {
        const filter = String(singleParamsModalState.search || '').trim().toLowerCase();
        const usageCounts = loadUsageCounts();
        const params = getCatalogParameters().filter((p) => {
          const key = String(p?.key || '').toLowerCase();
          const label = String(p?.label || '').toLowerCase();
          const labelLong = String(p?.labelLong || '').toLowerCase();
          return !filter || key.includes(filter) || label.includes(filter) || labelLong.includes(filter);
        }).sort((a, b) => {
          const keyA = String(a?.key || '').trim();
          const keyB = String(b?.key || '').trim();
          const labelA = getParameterDisplay(a, keyA).name;
          const labelB = getParameterDisplay(b, keyB).name;
          const usageA = Number(usageCounts[keyA] || 0);
          const usageB = Number(usageCounts[keyB] || 0);
          if (usageA !== usageB) return usageB - usageA;
          return labelA.localeCompare(labelB, 'de', { sensitivity: 'base' });
        });
        singleParamsList.innerHTML = '';
        if (params.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'meta';
          empty.textContent = 'Keine Parameter gefunden.';
          singleParamsList.appendChild(empty);
          return;
        }
        params.forEach((param) => {
          const key = String(param.key || '').trim();
          const selected = singleParamsModalState.toggles[key]?.selected === true;
          const row = document.createElement('div');
          row.className = 'list-item';
          row.style.cursor = 'pointer';
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr';
          row.style.gap = '4px';
          row.style.alignItems = 'center';
          row.setAttribute('role', 'button');
          row.tabIndex = 0;
          row.addEventListener('click', () => toggleSingleParamSelection(key));
          row.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              toggleSingleParamSelection(key);
            }
          });
          const left = document.createElement('div');
          const display = getParameterDisplay(param, key);
          left.textContent = display.short ? `${display.name} (${display.short})` : display.name;
          const group = findCatalogGroup(param.functionGroup);
          if (group) {
            const badge = document.createElement('small');
            badge.className = 'meta';
            badge.style.marginLeft = '0.5rem';
            badge.textContent = String(group.label || group.key || '').trim();
            left.appendChild(badge);
          }
          left.style.fontWeight = selected ? '600' : '400';
          if (selected) {
            row.style.background = 'color-mix(in srgb, var(--primary) 18%, transparent)';
            row.style.borderColor = 'var(--primary-strong)';
          } else {
            row.style.background = '';
            row.style.borderColor = '';
          }
          row.appendChild(left);
          singleParamsList.appendChild(row);
        });
      }

      function renderSelectedParamsList() {
        selectedParamsList.innerHTML = '';
        const selectedKeys = getSelectedParamKeys();
        if (selectedKeys.length === 0) {
          const empty = document.createElement('small');
          empty.className = 'meta';
          empty.textContent = 'Keine Parameter ausgewählt';
          selectedParamsList.appendChild(empty);
          return;
        }
        const mediaOrder = ['FS', 'H2O', '2e', '10e'];
        selectedKeys.forEach((key) => {
          const param = findCatalogParameter(key);
          if (!param) return;
          const toggle = singleParamsModalState.toggles[key];
          if (!toggle || toggle.selected !== true) return;
          const isVorOrt = toggle.vorOrt === true;
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
          if (toggle.media && typeof toggle.media === 'object') {
            Object.keys(toggle.media).forEach((medium) => {
              if (!allowedMedia.includes(medium)) delete toggle.media[medium];
            });
          }
          if (allowedLabs.length === 1) {
            toggle.lab = allowedLabs[0];
          }

          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr 44px 360px 84px';
          row.style.gap = '6px';
          row.style.alignItems = 'center';
          row.style.padding = '4px 0';
          row.style.fontSize = '13px';
          row.style.lineHeight = '1.2';
          row.style.borderBottom = '1px solid rgba(255,255,255,0.06)';

          const nameCell = document.createElement('div');
          nameCell.style.display = 'block';
          nameCell.style.fontSize = '13px';
          const label = document.createElement('span');
          label.style.display = 'block';
          label.style.maxWidth = '100%';
          label.style.overflow = 'hidden';
          label.style.textOverflow = 'ellipsis';
          label.style.whiteSpace = 'nowrap';
          const display = getParameterDisplay(param, key);
          const labelText = display.short ? `${display.name} (${display.short})` : display.name;
          label.textContent = labelText;
          label.title = labelText;
          nameCell.appendChild(label);
          row.appendChild(nameCell);

          const removeCell = document.createElement('div');
          removeCell.style.display = 'flex';
          removeCell.style.justifyContent = 'flex-end';
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = 'x';
          removeBtn.title = 'Entfernen';
          removeBtn.style.padding = '4px 8px';
          removeBtn.style.fontSize = '12px';
          removeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            toggleSingleParamSelection(key);
          });
          removeCell.appendChild(removeBtn);
          row.appendChild(removeCell);

          const actionsCell = document.createElement('div');
          actionsCell.style.justifySelf = 'end';
          actionsCell.style.display = 'flex';
          actionsCell.style.justifyContent = 'flex-end';
          actionsCell.style.gap = '6px';
          actionsCell.style.flexWrap = 'wrap';
          if (allowedLabs.length > 1) {
            const orderedLabs = [];
            ['EMD', 'HB'].forEach((lab) => {
              if (allowedLabs.includes(lab)) orderedLabs.push(lab);
            });
            allowedLabs.forEach((lab) => {
              if (!orderedLabs.includes(lab)) orderedLabs.push(lab);
            });
            orderedLabs.forEach((lab) => {
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = toggle.lab === lab ? 'primary' : 'secondary';
              btn.textContent = lab;
              btn.disabled = isVorOrt;
              btn.style.padding = '4px 8px';
              btn.style.fontSize = '12px';
              btn.addEventListener('click', () => setSingleParamLab(key, lab));
              actionsCell.appendChild(btn);
            });
          }
          const otherMediumName = String(param.otherMediumName || '').trim();
          const orderedAllowedMedia = [];
          mediaOrder.forEach((medium) => {
            if (allowedMedia.includes(medium)) orderedAllowedMedia.push(medium);
          });
          if (otherMediumName && (allowedMedia.includes(otherMediumName) || !orderedAllowedMedia.includes(otherMediumName))) {
            orderedAllowedMedia.push(otherMediumName);
          }
          orderedAllowedMedia.forEach((medium) => {
            const active = toggle.media && toggle.media[medium] === true;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = active ? 'primary' : 'secondary';
            btn.textContent = medium;
            btn.disabled = isVorOrt;
            btn.style.padding = '4px 8px';
            btn.style.fontSize = '12px';
            btn.addEventListener('click', () => toggleSingleParamMedium(key, medium));
            actionsCell.appendChild(btn);
          });
          row.appendChild(actionsCell);

          const vorOrtCell = document.createElement('div');
          vorOrtCell.style.display = 'flex';
          vorOrtCell.style.justifyContent = 'flex-end';
          vorOrtCell.style.justifySelf = 'end';
          if (param.allowVorOrt === true) {
            const vorOrtBtn = document.createElement('button');
            vorOrtBtn.type = 'button';
            vorOrtBtn.className = isVorOrt ? 'primary' : 'secondary';
            vorOrtBtn.textContent = 'vor Ort';
            vorOrtBtn.title = 'Als Vor-Ort-Parameter markieren';
            vorOrtBtn.style.whiteSpace = 'nowrap';
            vorOrtBtn.style.minWidth = '72px';
            vorOrtBtn.style.padding = '4px 8px';
            vorOrtBtn.style.fontSize = '12px';
            vorOrtBtn.addEventListener('click', (event) => {
              event.stopPropagation();
              toggleSingleParamVorOrt(key);
            });
            vorOrtCell.appendChild(vorOrtBtn);
          }
          row.appendChild(vorOrtCell);

          selectedParamsList.appendChild(row);
        });
      }

      function renderSingleParamsModal() {
        renderSingleParamsList();
        renderSelectedParamsList();
        updateSingleParamsModalPreview();
      }

      async function openSingleParamsModalForProbe(probeElement) {
        await loadSingleParameterCatalog();
        activeProbeForSingleParamsModal = probeElement;
        const packageValue = String(probeElement.querySelector('[name="packageId"]').value || '').trim();
        const packageEntry = packageValue ? getPackageById(packageValue) : null;
        const singleParamsInput = probeElement.querySelector('[name="singleParamsJson"]');
        const toggles = parseSingleParamsTogglesJson(singleParamsInput?.value);
        let packageBaseText = '';
        let packageDisplayName = '';
        let packageBaseToggles = {};
        let packageSelectedType = '';
        if (packageValue) {
          const pkg = packageEntry;
          packageBaseText = String(pkg?.text || '').trim();
          packageSelectedType = String(pkg?.type || '').trim() === 'builder' ? 'builder' : 'legacy';
          packageDisplayName = packageSelectedType === 'builder'
            ? String(pkg?.name || pkg?.displayName || pkg?.id || packageValue).trim()
            : String(pkg?.displayName || pkg?.name || pkg?.id || packageValue).trim();
          const definition = pkg && typeof pkg.definition === 'object' ? pkg.definition : {};
          packageBaseToggles = definition && typeof definition.toggles === 'object' ? definition.toggles : {};
        }
        openParamPickerModal('single', {
          initialToggles: toggles,
          packageSelectedType,
          packageDisplayName,
          packageBaseText,
          packageBaseToggles,
          legacyMergeStatus: '',
          legacyMergeReason: '',
        });
      }

      function closeSingleParamsModal() {
        activeProbeForSingleParamsModal = null;
        singleParamsModal.classList.add('hidden');
      }

      function applySingleParamsModal() {
        if (!activeProbeForSingleParamsModal) {
          closeSingleParamsModal();
          return;
        }
        const preview = updateSingleParamsModalPreview();
        const singleParamsInput = activeProbeForSingleParamsModal.querySelector('[name="singleParamsJson"]');
        const packageAddonsInput = activeProbeForSingleParamsModal.querySelector('[name="packageAddonsJson"]');
        const parameterTextInput = activeProbeForSingleParamsModal.querySelector('[name="parameterTextPreview"]');
        const toggles = normalizeSingleParamsToggles(singleParamsModalState.toggles);
        incrementUsageCountsForSelected(toggles);
        if (Object.keys(toggles).length === 0) {
          singleParamsInput.value = '';
        } else {
          singleParamsInput.value = JSON.stringify({ toggles });
        }
        packageAddonsInput.value = '';
        parameterTextInput.value = preview || '';
        setPackageText(activeProbeForSingleParamsModal);
        closeSingleParamsModal();
      }

      function getPackageBuilderSelectedKeys() {
        return Object.keys(packageBuilderState.toggles || {}).filter((key) => packageBuilderState.toggles[key]?.selected === true);
      }

      function togglePackageBuilderSelection(key) {
        const param = findCatalogParameter(key);
        if (!param) return;
        if (packageBuilderState.toggles[key]?.selected === true) {
          delete packageBuilderState.toggles[key];
        } else {
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const lab = allowedLabs.includes(String(param.defaultLab || '').trim())
            ? String(param.defaultLab || '').trim()
            : (allowedLabs[0] || '');
          packageBuilderState.toggles[key] = {
            selected: true,
            lab,
            media: {},
            vorOrt: false,
          };
        }
        renderPackageBuilderModal();
      }

      function setPackageBuilderLab(key, lab) {
        const param = findCatalogParameter(key);
        if (!param) return;
        const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
        if (!allowedLabs.includes(lab)) return;
        if (!packageBuilderState.toggles[key]?.selected) return;
        if (packageBuilderState.toggles[key].vorOrt === true) return;
        packageBuilderState.toggles[key].lab = lab;
        renderPackageBuilderModal();
      }

      function togglePackageBuilderMedium(key, medium) {
        const param = findCatalogParameter(key);
        if (!param) return;
        const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
        if (!allowedMedia.includes(medium)) return;
        if (!packageBuilderState.toggles[key]?.selected) return;
        if (packageBuilderState.toggles[key].vorOrt === true) return;
        const media = packageBuilderState.toggles[key].media || {};
        if (media[medium] === true) {
          delete media[medium];
        } else {
          media[medium] = true;
        }
        packageBuilderState.toggles[key].media = media;
        renderPackageBuilderModal();
      }

      function togglePackageBuilderVorOrt(key) {
        const param = findCatalogParameter(key);
        if (!param || param.allowVorOrt !== true) return;
        if (!packageBuilderState.toggles[key]?.selected) return;
        packageBuilderState.toggles[key].vorOrt = packageBuilderState.toggles[key].vorOrt !== true;
        renderPackageBuilderModal();
      }

      function buildPackageBuilderPreviewText() {
        const name = String(packageBuilderState.name || '').trim() || 'Neues Paket';
        const text = buildPreviewTextFromToggles(singleParamsCatalog, packageBuilderState.toggles);
        return text ? `PKT: ${name}\n${text}` : `PKT: ${name}`;
      }

      function updatePackageBuilderPreview() {
        const preview = buildPackageBuilderPreviewText();
        const escapeHtml = (value) => String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
        const html = String(preview || '')
          .split('\n')
          .map((line) => {
            const match = line.match(/^([^:]+:)(.*)$/);
            if (!match) return `<div>${escapeHtml(line)}</div>`;
            const head = escapeHtml(match[1]);
            const tail = escapeHtml(match[2] || '');
            return `<div><strong>${head}</strong>${tail}</div>`;
          })
          .join('');
        packageBuilderPreview.innerHTML = html;
        return preview;
      }

      function renderPackageBuilderList() {
        const filter = String(packageBuilderState.search || '').trim().toLowerCase();
        const usageCounts = loadUsageCounts();
        const params = getCatalogParameters().filter((p) => {
          const key = String(p?.key || '').toLowerCase();
          const label = String(p?.label || '').toLowerCase();
          const labelLong = String(p?.labelLong || '').toLowerCase();
          return !filter || key.includes(filter) || label.includes(filter) || labelLong.includes(filter);
        }).sort((a, b) => {
          const keyA = String(a?.key || '').trim();
          const keyB = String(b?.key || '').trim();
          const labelA = getParameterDisplay(a, keyA).name;
          const labelB = getParameterDisplay(b, keyB).name;
          const usageA = Number(usageCounts[keyA] || 0);
          const usageB = Number(usageCounts[keyB] || 0);
          if (usageA !== usageB) return usageB - usageA;
          return labelA.localeCompare(labelB, 'de', { sensitivity: 'base' });
        });
        packageBuilderList.innerHTML = '';
        if (params.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'meta';
          empty.textContent = 'Keine Parameter gefunden.';
          packageBuilderList.appendChild(empty);
          return;
        }
        params.forEach((param) => {
          const key = String(param.key || '').trim();
          const selected = packageBuilderState.toggles[key]?.selected === true;
          const row = document.createElement('div');
          row.className = 'list-item';
          row.style.cursor = 'pointer';
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr';
          row.style.gap = '4px';
          row.style.alignItems = 'center';
          row.setAttribute('role', 'button');
          row.tabIndex = 0;
          row.addEventListener('click', () => togglePackageBuilderSelection(key));
          row.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              togglePackageBuilderSelection(key);
            }
          });
          const left = document.createElement('div');
          const display = getParameterDisplay(param, key);
          left.textContent = display.short ? `${display.name} (${display.short})` : display.name;
          const group = findCatalogGroup(param.functionGroup);
          if (group) {
            const badge = document.createElement('small');
            badge.className = 'meta';
            badge.style.marginLeft = '0.5rem';
            badge.textContent = String(group.label || group.key || '').trim();
            left.appendChild(badge);
          }
          left.style.fontWeight = selected ? '600' : '400';
          if (selected) {
            row.style.background = 'color-mix(in srgb, var(--primary) 18%, transparent)';
            row.style.borderColor = 'var(--primary-strong)';
          }
          row.appendChild(left);
          packageBuilderList.appendChild(row);
        });
      }

      function renderPackageBuilderSelectedList() {
        packageBuilderSelectedList.innerHTML = '';
        const selectedKeys = getPackageBuilderSelectedKeys();
        if (selectedKeys.length === 0) {
          const empty = document.createElement('small');
          empty.className = 'meta';
          empty.textContent = 'Keine Parameter ausgewählt';
          packageBuilderSelectedList.appendChild(empty);
          return;
        }
        const mediaOrder = ['FS', 'H2O', '2e', '10e'];
        selectedKeys.forEach((key) => {
          const param = findCatalogParameter(key);
          if (!param) return;
          const toggle = packageBuilderState.toggles[key];
          if (!toggle || toggle.selected !== true) return;
          const isVorOrt = toggle.vorOrt === true;
          const allowedLabs = Array.isArray(param.allowedLabs) ? param.allowedLabs : [];
          const allowedMedia = Array.isArray(param.allowedMedia) ? param.allowedMedia : [];
          if (toggle.media && typeof toggle.media === 'object') {
            Object.keys(toggle.media).forEach((medium) => {
              if (!allowedMedia.includes(medium)) delete toggle.media[medium];
            });
          }
          if (allowedLabs.length === 1) {
            toggle.lab = allowedLabs[0];
          }
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr 44px 360px 84px';
          row.style.gap = '6px';
          row.style.alignItems = 'center';
          row.style.padding = '4px 0';
          row.style.fontSize = '13px';
          row.style.lineHeight = '1.2';
          row.style.borderBottom = '1px solid rgba(255,255,255,0.06)';

          const nameCell = document.createElement('div');
          const label = document.createElement('span');
          label.style.display = 'block';
          label.style.maxWidth = '100%';
          label.style.overflow = 'hidden';
          label.style.textOverflow = 'ellipsis';
          label.style.whiteSpace = 'nowrap';
          const display = getParameterDisplay(param, key);
          const labelText = display.short ? `${display.name} (${display.short})` : display.name;
          label.textContent = labelText;
          label.title = labelText;
          nameCell.appendChild(label);
          row.appendChild(nameCell);

          const removeCell = document.createElement('div');
          removeCell.style.display = 'flex';
          removeCell.style.justifyContent = 'flex-end';
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = 'x';
          removeBtn.title = 'Entfernen';
          removeBtn.style.padding = '4px 8px';
          removeBtn.style.fontSize = '12px';
          removeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            togglePackageBuilderSelection(key);
          });
          removeCell.appendChild(removeBtn);
          row.appendChild(removeCell);

          const actionsCell = document.createElement('div');
          actionsCell.style.justifySelf = 'end';
          actionsCell.style.display = 'flex';
          actionsCell.style.justifyContent = 'flex-end';
          actionsCell.style.gap = '6px';
          actionsCell.style.flexWrap = 'wrap';
          if (allowedLabs.length > 1) {
            const orderedLabs = [];
            ['EMD', 'HB'].forEach((lab) => {
              if (allowedLabs.includes(lab)) orderedLabs.push(lab);
            });
            allowedLabs.forEach((lab) => {
              if (!orderedLabs.includes(lab)) orderedLabs.push(lab);
            });
            orderedLabs.forEach((lab) => {
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = toggle.lab === lab ? 'primary' : 'secondary';
              btn.textContent = lab;
              btn.disabled = isVorOrt;
              btn.style.padding = '4px 8px';
              btn.style.fontSize = '12px';
              btn.addEventListener('click', () => setPackageBuilderLab(key, lab));
              actionsCell.appendChild(btn);
            });
          }
          const otherMediumName = String(param.otherMediumName || '').trim();
          const orderedAllowedMedia = [];
          mediaOrder.forEach((medium) => {
            if (allowedMedia.includes(medium)) orderedAllowedMedia.push(medium);
          });
          if (otherMediumName && (allowedMedia.includes(otherMediumName) || !orderedAllowedMedia.includes(otherMediumName))) {
            orderedAllowedMedia.push(otherMediumName);
          }
          orderedAllowedMedia.forEach((medium) => {
            const active = toggle.media && toggle.media[medium] === true;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = active ? 'primary' : 'secondary';
            btn.textContent = medium;
            btn.disabled = isVorOrt;
            btn.style.padding = '4px 8px';
            btn.style.fontSize = '12px';
            btn.addEventListener('click', () => togglePackageBuilderMedium(key, medium));
            actionsCell.appendChild(btn);
          });
          row.appendChild(actionsCell);

          const vorOrtCell = document.createElement('div');
          vorOrtCell.style.display = 'flex';
          vorOrtCell.style.justifyContent = 'flex-end';
          vorOrtCell.style.justifySelf = 'end';
          if (param.allowVorOrt === true) {
            const vorOrtBtn = document.createElement('button');
            vorOrtBtn.type = 'button';
            vorOrtBtn.className = isVorOrt ? 'primary' : 'secondary';
            vorOrtBtn.textContent = 'vor Ort';
            vorOrtBtn.title = 'Als Vor-Ort-Parameter markieren';
            vorOrtBtn.style.whiteSpace = 'nowrap';
            vorOrtBtn.style.minWidth = '72px';
            vorOrtBtn.style.padding = '4px 8px';
            vorOrtBtn.style.fontSize = '12px';
            vorOrtBtn.addEventListener('click', (event) => {
              event.stopPropagation();
              togglePackageBuilderVorOrt(key);
            });
            vorOrtCell.appendChild(vorOrtBtn);
          }
          row.appendChild(vorOrtCell);
          packageBuilderSelectedList.appendChild(row);
        });
      }

      function renderPackageBuilderModal() {
        renderPackageBuilderList();
        renderPackageBuilderSelectedList();
        updatePackageBuilderPreview();
      }

      function openParamPickerModal(mode, ctx = {}) {
        if (mode === 'single') {
          singleParamsModalState = {
            toggles: ctx.initialToggles || {},
            search: '',
            packageSelectedType: String(ctx.packageSelectedType || '').trim(),
            packageDisplayName: String(ctx.packageDisplayName || '').trim(),
            packageBaseText: String(ctx.packageBaseText || '').trim(),
            packageBaseToggles: ctx.packageBaseToggles || {},
            legacyMergeStatus: String(ctx.legacyMergeStatus || '').trim(),
            legacyMergeReason: String(ctx.legacyMergeReason || '').trim(),
          };
          singleParamsSearchInput.value = '';
          renderSingleParamsModal();
          singleParamsModal.classList.remove('hidden');
          return;
        }
        if (mode === 'packageBuilder') {
          packageBuilderState = {
            editId: String(ctx.editId || '').trim(),
            name: String(ctx.name || '').trim(),
            search: '',
            toggles: ctx.initialToggles || {},
          };
          packageBuilderNameInput.value = packageBuilderState.name;
          packageBuilderSearchInput.value = '';
          renderPackageBuilderModal();
          packageBuilderModal.classList.remove('hidden');
          setTimeout(() => packageBuilderNameInput.focus(), 0);
        }
      }

      function resolveBuilderPackagePrefillFromCurrentProbe() {
        const activeRow = (document.activeElement && document.activeElement.closest)
          ? document.activeElement.closest('.probe-row')
          : null;
        const probeRow = activeRow || probenContainer.querySelector('.probe-row');
        if (!probeRow) return null;
        const packageSelect = probeRow.querySelector('[name="packageId"]');
        const selectedPackageId = String(packageSelect?.value || '').trim();
        if (!selectedPackageId || !selectedPackageId.startsWith('builder:')) {
          return null;
        }
        const builderPackage = getPackageById(selectedPackageId);
        if (!builderPackage || builderPackage.type !== 'builder') return null;
        const definition = builderPackage.definition && typeof builderPackage.definition === 'object'
          ? builderPackage.definition
          : {};
        const toggles = normalizeSingleParamsToggles(definition.toggles);
        return {
          editId: selectedPackageId.replace(/^builder:/, '').trim(),
          name: String(builderPackage.name || '').trim(),
          toggles,
        };
      }

      function openPackageBuilderModal() {
        const prefill = resolveBuilderPackagePrefillFromCurrentProbe();
        openPackageBuilderModalWithState(prefill || {
          editId: '',
          name: '',
          toggles: {},
        });
      }

      function openPackageBuilderModalWithState(initialState = {}) {
        const initialToggles = initialState && typeof initialState.toggles === 'object' ? initialState.toggles : {};
        const normalizedToggles = normalizeSingleParamsToggles(initialToggles);
        openParamPickerModal('packageBuilder', {
          editId: String(initialState?.editId || '').trim(),
          name: String(initialState?.name || '').trim(),
          initialToggles: normalizedToggles,
        });
      }

      function closePackageBuilderModal() {
        packageBuilderModal.classList.add('hidden');
      }

      async function savePackageBuilderModal() {
        const name = String(packageBuilderState.name || '').trim();
        if (!name) {
          showToast('error', 'Paketname ist erforderlich');
          packageBuilderNameInput.focus();
          return;
        }
        const toggles = normalizeSingleParamsToggles(packageBuilderState.toggles);
        const response = await fetch('/api/builder-packages', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: packageBuilderState.editId || null,
            name,
            definition: { toggles },
          }),
        });
        const data = await response.json();
        if (!response.ok || data.ok !== true) {
          throw new Error(data?.message || 'Builder-Paket konnte nicht gespeichert werden');
        }
        showToast('success', packageBuilderState.editId ? 'Builder-Paket aktualisiert' : 'Builder-Paket gespeichert');
        await loadPackages();
        refreshAllPackageSelects();
        closePackageBuilderModal();
      }

      function maybeOpenPackageBuilderEditFromQuery() {
        const params = new URLSearchParams(window.location.search || '');
        const openBuilder = String(params.get('openPackageBuilder') || '').trim();
        if (openBuilder === '1') {
          openPackageBuilderModalWithState({
            editId: '',
            name: '',
            toggles: {},
          });
          params.delete('openPackageBuilder');
          const openQuery = params.toString();
          const openUrl = `${window.location.pathname}${openQuery ? `?${openQuery}` : ''}${window.location.hash || ''}`;
          window.history.replaceState({}, '', openUrl);
          return;
        }
        const rawId = String(params.get('editBuilderPackage') || '').trim();
        if (!rawId) return;
        const packageId = rawId.startsWith('builder:') ? rawId : `builder:${rawId}`;
        const builderPackage = packages.find((pkg) => pkg.type === 'builder' && String(pkg.id || '').trim() === packageId);
        if (!builderPackage) {
          showToast('error', 'Builder-Paket zum Bearbeiten nicht gefunden');
          return;
        }
        const definition = builderPackage.definition && typeof builderPackage.definition === 'object' ? builderPackage.definition : {};
        const toggles = definition.toggles && typeof definition.toggles === 'object' ? definition.toggles : {};
        openPackageBuilderModalWithState({
          editId: String(packageId.replace(/^builder:/, '')).trim(),
          name: String(builderPackage.name || '').trim(),
          toggles,
        });
        params.delete('editBuilderPackage');
        const nextQuery = params.toString();
        const nextUrl = `${window.location.pathname}${nextQuery ? `?${nextQuery}` : ''}${window.location.hash || ''}`;
        window.history.replaceState({}, '', nextUrl);
      }

      function populatePackageSelect(probeElement) {
        const packageSelect = probeElement.querySelector('[name="packageId"]');
        packageSelect.innerHTML = '<option value="">Bitte wählen</option>';
        packages.forEach((pkg) => {
          const option = document.createElement('option');
          option.value = pkg.id;
          const displayName = String(pkg.displayName || pkg.name || pkg.id || '').trim();
          const shortText = String(pkg.shortText || '').trim();
          option.textContent = shortText ? `${displayName} - ${shortText}` : displayName;
          packageSelect.appendChild(option);
        });
        packageSelect.onchange = () => setPackageText(probeElement);
      }

      function refreshAllPackageSelects() {
        Array.from(probenContainer.querySelectorAll('.probe-row')).forEach((probeElement) => {
          const packageSelect = probeElement.querySelector('[name="packageId"]');
          const currentValue = String(packageSelect?.value || '').trim();
          populatePackageSelect(probeElement);
          if (packageSelect) {
            packageSelect.value = currentValue;
          }
          setPackageText(probeElement);
        });
      }

      function updateProbeIndexes() {
        // No-op, row numbering column removed.
      }

      function wireProbeActions(probeElement) {
        const duplicateButton = probeElement.querySelector('[data-action="duplicate"]');
        const deleteButton = probeElement.querySelector('[data-action="delete"]');
        const gebindeButton = probeElement.querySelector('[data-action="gebinde"]');
        const geruchButton = probeElement.querySelector('[data-action="geruch"]');
        const singleParamsButton = probeElement.querySelector('[data-action="single-params"]');
        const probeNoteButton = probeElement.querySelector('[data-action="probe-note"]');
        const nameInput = probeElement.querySelector('[name="probenbezeichnung"]');

        if (gebindeButton) gebindeButton.textContent = '◐';
        if (geruchButton) geruchButton.textContent = '◍';
        if (duplicateButton) duplicateButton.textContent = '⧉';
        if (deleteButton) deleteButton.textContent = '✕';

        duplicateButton.addEventListener('click', () => duplicateProbe(probeElement));
        deleteButton.addEventListener('click', () => deleteProbe(probeElement));
        gebindeButton.addEventListener('click', () => openGebindeModalForProbe(probeElement));
        geruchButton.addEventListener('click', () => openGeruchModalForProbe(probeElement));
        if (singleParamsButton) {
          singleParamsButton.addEventListener('click', () => openSingleParamsModalForProbe(probeElement));
        }
        if (probeNoteButton) {
          probeNoteButton.addEventListener('click', () => openProbeNoteModalForProbe(probeElement));
        }
        nameInput.addEventListener('input', () => {
          nameInput.title = nameInput.value;
          const hiddenInput = probeElement.querySelector('[name="probenbezeichnungFull"]');
          if (hiddenInput) hiddenInput.value = normalizeProbeNameText(nameInput.value, false);
          autoSizeProbeNameInput(nameInput);
        });
        autoSizeProbeNameInput(nameInput);
        updateProbeNoteButton(probeElement);
      }

      function addProbe(initialData = null) {
        const fragment = probeTemplate.content.cloneNode(true);
        const probeElement = fragment.querySelector('.probe-row');
        populatePackageSelect(probeElement);
        wireProbeActions(probeElement);

        if (initialData) {
          setProbeNameValue(probeElement, initialData.probenbezeichnung || '');
          probeElement.querySelector('[name="material"]').value = initialData.material ?? '';
          probeElement.querySelector('[name="tiefeVolumen"]').value = initialData.tiefeVolumen ?? '';
          probeElement.querySelector('[name="gewicht"]').value = initialData.gewicht ?? '';
          setProbeGeruchData(probeElement, initialData.geruch || null);
          probeElement.querySelector('[name="bemerkung"]').value = initialData.bemerkung ?? '';
          probeElement.querySelector('[name="packageId"]').value = initialData.packageId || '';
          probeElement.querySelector('[name="singleParamsJson"]').value = initialData.singleParamsJson || '';
          probeElement.querySelector('[name="packageAddonsJson"]').value = initialData.packageAddonsJson || '';
          probeElement.querySelector('[name="parameterTextPreview"]').value = initialData.parameterTextPreview || '';
          setProbeContainersData(probeElement, initialData.containers || null);
        } else {
          setProbeNameValue(probeElement, '');
          setProbeGeruchData(probeElement, null);
          probeElement.querySelector('[name="bemerkung"]').value = '';
          setProbeContainersData(probeElement, null);
        }

        updateProbeNoteButton(probeElement);
        setPackageText(probeElement);
        probenContainer.appendChild(fragment);
        updateProbeIndexes();
        updateProbeGebindeUiState();
      }

      function duplicateProbe(probeElement) {
        const containers = getProbeContainersData(probeElement);
        const initialData = {
          probenbezeichnung: getProbeFullName(probeElement),
          material: probeElement.querySelector('[name="material"]').value,
          packageId: probeElement.querySelector('[name="packageId"]').value,
          singleParamsJson: probeElement.querySelector('[name="singleParamsJson"]').value,
          packageAddonsJson: probeElement.querySelector('[name="packageAddonsJson"]').value,
          parameterTextPreview: probeElement.querySelector('[name="parameterTextPreview"]').value,
          tiefeVolumen: probeElement.querySelector('[name="tiefeVolumen"]').value,
          gewicht: probeElement.querySelector('[name="gewicht"]').value,
          geruch: getProbeGeruchData(probeElement),
          bemerkung: probeElement.querySelector('[name="bemerkung"]').value,
          containers,
        };
        addProbe(initialData);
      }

      function deleteProbe(probeElement) {
        probeElement.remove();
        updateProbeIndexes();
        updateProbeGebindeUiState();
      }

      function buildPayload() {
        const probeNochNichtDa = probeNochNichtDaInput.checked;
        const sameContainersForAll = sameContainersForAllInput.checked;
        return {
          kunde: form.kunde.value.trim(),
          projektnummer: form.projektnummer.value.trim(),
          projektName: form.projektName.value.trim(),
          ansprechpartner: form.ansprechpartner.value.trim() || undefined,
          email: form.email.value.trim() || undefined,
          kopfBemerkung: form.kopfBemerkung.value.trim() || undefined,
          auftragsnotiz: form.kopfBemerkung.value.trim() || undefined,
          adresseBlock: adresseBlockInput.value.trim() || undefined,
          erfasstKuerzel: form.erfasstKuerzel.value.trim().toUpperCase() || undefined,
          kuerzel: form.erfasstKuerzel.value.trim().toUpperCase() || undefined,
          eilig: eiligValueInput.value === 'ja',
          probentransport: probentransportValueInput.value === 'AG' ? 'AG' : 'CUA',
          sameContainersForAll,
          headerContainers: sameContainersForAll ? getHeaderContainersData() : undefined,
          probeNochNichtDa,
          probenahmedatum: probenahmedatumInput.value || undefined,
          samplers: selectedSamplers.length > 0 ? [...selectedSamplers] : undefined,
          probenEingangDatum: probeNochNichtDa ? undefined : probenEingangDatumInput.value || undefined,
          proben: Array.from(probenContainer.querySelectorAll('.probe-row')).map((probe) => {
            const tiefeVolumenRaw = probe.querySelector('[name="tiefeVolumen"]').value.trim();
            const tiefeVolumenNum = parseNumberOrUndefined(tiefeVolumenRaw);
            const material = probe.querySelector('[name="material"]').value.trim();
            const geruchData = getProbeGeruchData(probe);
            const geruchValue = buildGeruchPayloadValue(geruchData.option, geruchData.sonstiges);
            let singleParams = undefined;
            const singleParamsRaw = String(probe.querySelector('[name="singleParamsJson"]').value || '').trim();
            if (singleParamsRaw) {
              try {
                const parsed = JSON.parse(singleParamsRaw);
                if (parsed && typeof parsed === 'object') {
                  singleParams = parsed;
                }
              } catch (_error) {
                singleParams = undefined;
              }
            }
            return {
              probenbezeichnung: getProbeFullName(probe),
              material: material || undefined,
              packageId: probe.querySelector('[name="packageId"]').value || undefined,
              parameterTextPreview: probe.querySelector('[name="parameterTextPreview"]').value.trim() || undefined,
              singleParams,
              tiefeVolumen: tiefeVolumenRaw || undefined,
              tiefeOderVolumen: tiefeVolumenRaw || undefined,
              volumen: tiefeVolumenNum,
              gewicht: parseNumberOrUndefined(probe.querySelector('[name="gewicht"]').value),
              gewichtEinheit: 'kg',
              geruch: geruchValue || undefined,
              geruchAuffaelligkeit: geruchValue || undefined,
              geruchOption: geruchData.option || undefined,
              geruchSonstiges: geruchData.option === 'sonstiges' ? (geruchData.sonstiges || undefined) : undefined,
              bemerkung: probe.querySelector('[name="bemerkung"]').value.trim() || undefined,
              containers: sameContainersForAll ? undefined : getProbeContainersData(probe),
            };
          }),
        };
      }

      async function sendOrder(endpoint, options = {}) {
        const { extraHeaders = {}, payload = buildPayload(), isCommit = false } = options;
        clearErrorPanel();

        try {
          if (isCommit) {
            setCommitUiState(true);
            setCommitFeedback('info', 'Sende...');
            retryCommitButton.classList.add('hidden');
            commitSlowTimer = window.setTimeout(() => {
              setCommitFeedback('info', 'Bitte warten... Excel wird aktualisiert');
            }, 2000);
          } else {
            setDraftUiState(true);
          }

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...extraHeaders,
            },
            body: JSON.stringify(payload),
          });

          const data = await response.json();

          if (isCommit) {
            if (response.ok && data.ok) {
              setCommitFeedback('success', formatSuccessMessage(data));
              showToast('success', formatSuccessMessage(data));
              lastFailedCommitContext = null;
              retryCommitButton.classList.add('hidden');
              loadCustomers().catch(() => {});
            } else {
              const info = normalizeApiError(data, 'Commit fehlgeschlagen');
              setCommitFeedback('error', info.userMessage);
              showToast('error', info.userMessage);
              showErrorPanel(info.userMessage, data, info.debug);
              retryCommitButton.classList.remove('hidden');
              lastFailedCommitContext = {
                payload,
                extraHeaders,
                clientRequestId: payload.clientRequestId,
              };
            }
          } else {
            if (response.ok && data.ok) {
              showToast('success', 'Draft erfolgreich erstellt');
              loadCustomers().catch(() => {});
            } else {
              const info = normalizeApiError(data, 'Draft fehlgeschlagen');
              showToast('error', info.userMessage);
              showErrorPanel(info.userMessage, data, info.debug);
            }
          }
        } catch (error) {
          const message = `Request fehlgeschlagen: ${error.message}`;
          showToast('error', message);
          showErrorPanel(message);
          if (isCommit) {
            setCommitFeedback('error', `Commit fehlgeschlagen: ${error.message}`);
            retryCommitButton.classList.remove('hidden');
            lastFailedCommitContext = { payload, extraHeaders, clientRequestId: payload.clientRequestId };
          }
        } finally {
          if (isCommit) {
            if (commitSlowTimer) {
              window.clearTimeout(commitSlowTimer);
              commitSlowTimer = null;
            }
            setCommitUiState(false);
          } else {
            setDraftUiState(false);
          }
        }
      }

      addProbeButton.addEventListener('click', addProbe);
      newOrderButton.addEventListener('click', resetForNewOrder);
      openCustomersModalButton.addEventListener('click', openCustomersModal);
      newOrderSameProjectButton.addEventListener('click', resetForNewOrderSameProject);
      openBulkProbeModalButton.addEventListener('click', openBulkProbeModal);
      probeNochNichtDaInput.addEventListener('change', updateEingangDatumState);
      openKuerzelModalButton.addEventListener('click', openKuerzelModal);
      kuerzelModalClose.addEventListener('click', closeKuerzelModal);
      kuerzelModalReset.addEventListener('click', resetKuerzelValue);
      kuerzelCustomApply.addEventListener('click', applyKuerzelFromCustomInput);
      kuerzelCustomInput.addEventListener('input', () => {
        pendingKuerzelSelection = normalizeKuerzelValue(kuerzelCustomInput.value);
        renderKuerzelPresetButtons();
      });
      kuerzelCustomInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applyKuerzelFromCustomInput();
        }
      });
      kuerzelModal.addEventListener('click', (event) => {
        if (event.target === kuerzelModal) closeKuerzelModal();
      });
      openSamplersModalButton.addEventListener('click', openSamplersModal);
      samplersModalCancel.addEventListener('click', closeSamplersModal);
      samplersModalApply.addEventListener('click', applySamplersModal);
      samplersModal.addEventListener('click', (event) => {
        if (event.target === samplersModal) closeSamplersModal();
      });
      openKopfBemerkungModalButton.addEventListener('click', openKopfBemerkungModal);
      kopfBemerkungModalCancel.addEventListener('click', closeKopfBemerkungModal);
      kopfBemerkungModalApply.addEventListener('click', applyKopfBemerkungModal);
      kopfBemerkungModal.addEventListener('click', (event) => {
        if (event.target === kopfBemerkungModal) closeKopfBemerkungModal();
      });
      eiligToggle.addEventListener('click', () => {
        setEiligState(eiligValueInput.value !== 'ja');
      });
      probentransportToggle.addEventListener('click', () => {
        setProbentransportState(probentransportValueInput.value === 'CUA' ? 'AG' : 'CUA');
      });
      sameContainersForAllInput.addEventListener('change', updateProbeGebindeUiState);
      openHeaderGebindeModalButton.addEventListener('click', openGebindeModalForHeader);
      openAddressModalButton.addEventListener('click', openAddressModal);
      form.kunde.addEventListener('change', autofillCustomerProfile);
      form.kunde.addEventListener('blur', autofillCustomerProfile);
      customersSearchInput.addEventListener('input', () => {
        activeCustomerSearch = customersSearchInput.value;
        renderCustomerList();
      });
      customersModalClose.addEventListener('click', closeCustomersModal);
      customersModal.addEventListener('click', (event) => {
        if (event.target === customersModal) closeCustomersModal();
      });
      customersRefreshFromExcelButton.addEventListener('click', refreshCustomersFromExcel);
      importantFieldsCancel.addEventListener('click', () => resolveImportantFieldsModal(false));
      importantFieldsProceed.addEventListener('click', () => resolveImportantFieldsModal(true));
      importantFieldsModal.addEventListener('click', (event) => {
        if (event.target === importantFieldsModal) {
          resolveImportantFieldsModal(false);
        }
      });
      customerDeleteCancel.addEventListener('click', () => resolveCustomerDeleteModal(false));
      customerDeleteConfirm.addEventListener('click', () => resolveCustomerDeleteModal(true));
      customerDeleteModal.addEventListener('click', (event) => {
        if (event.target === customerDeleteModal) {
          resolveCustomerDeleteModal(false);
        }
      });
      [addressFirmaInput, addressZhInput, addressStrasseInput, addressHausnummerInput, addressPlzInput, addressOrtInput].forEach((input) => {
        input.addEventListener('input', updateAddressPreviewBlock);
      });
      addressOrtInput.addEventListener('blur', () => {
        addressOrtInput.value = String(addressOrtInput.value || '').toUpperCase();
        updateAddressPreviewBlock();
      });
      addressModalCancel.addEventListener('click', closeAddressModal);
      addressModalApply.addEventListener('click', applyAddressModal);
      addressModal.addEventListener('click', (event) => {
        if (event.target === addressModal) closeAddressModal();
      });
      singleParamsSearchInput.addEventListener('input', () => {
        singleParamsModalState.search = singleParamsSearchInput.value;
        renderSingleParamsModal();
      });
      openPackageBuilderModalButton.addEventListener('click', openPackageBuilderModal);
      packageBuilderNameInput.addEventListener('input', () => {
        packageBuilderState.name = packageBuilderNameInput.value;
        updatePackageBuilderPreview();
      });
      packageBuilderSearchInput.addEventListener('input', () => {
        packageBuilderState.search = packageBuilderSearchInput.value;
        renderPackageBuilderModal();
      });
      packageBuilderCancel.addEventListener('click', closePackageBuilderModal);
      packageBuilderSave.addEventListener('click', async () => {
        try {
          packageBuilderSave.disabled = true;
          await savePackageBuilderModal();
        } catch (error) {
          showToast('error', error.message);
        } finally {
          packageBuilderSave.disabled = false;
        }
      });
      packageBuilderModal.addEventListener('click', (event) => {
        if (event.target === packageBuilderModal) closePackageBuilderModal();
      });
      singleParamsCancel.addEventListener('click', closeSingleParamsModal);
      singleParamsApply.addEventListener('click', applySingleParamsModal);
      singleParamsModal.addEventListener('click', (event) => {
        if (event.target === singleParamsModal) closeSingleParamsModal();
      });

      bulkProbeModalCancel.addEventListener('click', closeBulkProbeModal);
      bulkProbeModalApply.addEventListener('click', applyBulkProbeInsert);
      bulkProbeModal.addEventListener('click', (event) => {
        if (event.target === bulkProbeModal) closeBulkProbeModal();
      });
      geruchOptionInput.addEventListener('change', updateGeruchSonstigesVisibility);
      geruchModalCancel.addEventListener('click', closeGeruchModal);
      geruchModalApply.addEventListener('click', applyGeruchModal);
      geruchModal.addEventListener('click', (event) => {
        if (event.target === geruchModal) closeGeruchModal();
      });
      probeNoteCancel.addEventListener('click', closeProbeNoteModal);
      probeNoteApply.addEventListener('click', applyProbeNoteModal);
      probeNoteModal.addEventListener('click', (event) => {
        if (event.target === probeNoteModal) closeProbeNoteModal();
      });
      gebindeModalCancel.addEventListener('click', closeGebindeModal);
      gebindeModalApply.addEventListener('click', applyGebindeModal);
      gebindeUndoButton.addEventListener('click', () => {
        if (!activeGebindeTarget || activeGebindeTarget.containers.items.length === 0) return;
        activeGebindeTarget.containers.items.pop();
        updateGebindeModalPreview();
        renderGebindeQuickButtons(activeGebindeTab);
      });
      gebindeResetButton.addEventListener('click', () => {
        if (!activeGebindeTarget) return;
        activeGebindeTarget.containers.items = [];
        activeGebindeTarget.containers.history = [];
        updateGebindeModalPreview();
        renderGebindeQuickButtons(activeGebindeTab);
      });
      Array.from(gebindeModal.querySelectorAll('[data-tab]')).forEach((tabBtn) => {
        tabBtn.addEventListener('click', () => {
          setGebindeModalTab(tabBtn.dataset.tab);
        });
      });
      gebindeModal.addEventListener('click', (event) => {
        if (event.target === gebindeModal) closeGebindeModal();
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && !importantFieldsModal.classList.contains('hidden')) {
          resolveImportantFieldsModal(false);
          return;
        }
        if (event.key === 'Escape' && !customerDeleteModal.classList.contains('hidden')) {
          resolveCustomerDeleteModal(false);
          return;
        }
        if (event.key === 'Escape' && !bulkProbeModal.classList.contains('hidden')) {
          closeBulkProbeModal();
          return;
        }
        if (event.key === 'Escape' && !gebindeModal.classList.contains('hidden')) {
          closeGebindeModal();
          return;
        }
        if (event.key === 'Escape' && !geruchModal.classList.contains('hidden')) {
          closeGeruchModal();
          return;
        }
        if (event.key === 'Escape' && !probeNoteModal.classList.contains('hidden')) {
          closeProbeNoteModal();
          return;
        }
        if (event.key === 'Escape' && !customersModal.classList.contains('hidden')) {
          closeCustomersModal();
          return;
        }
        if (event.key === 'Escape' && !kuerzelModal.classList.contains('hidden')) {
          closeKuerzelModal();
          return;
        }
        if (event.key === 'Escape' && !samplersModal.classList.contains('hidden')) {
          closeSamplersModal();
          return;
        }
        if (event.key === 'Escape' && !kopfBemerkungModal.classList.contains('hidden')) {
          closeKopfBemerkungModal();
          return;
        }
        if (event.key === 'Escape' && !addressModal.classList.contains('hidden')) {
          closeAddressModal();
          return;
        }
        if (event.key === 'Escape' && !singleParamsModal.classList.contains('hidden')) {
          closeSingleParamsModal();
          return;
        }
        if (event.key === 'Escape' && !packageBuilderModal.classList.contains('hidden')) {
          closePackageBuilderModal();
        }
      });
      probenContainer.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter') return;
        const target = event.target;
        if (!target || !(target instanceof HTMLElement)) return;
        if (!target.closest('.probe-row')) return;
        if (target.tagName === 'TEXTAREA') return;
        event.preventDefault();

        const row = target.closest('.probe-row');
        const focusablesInRow = Array.from(
          row.querySelectorAll('input:not([type="hidden"]), select, button[data-action="single-params"], button[data-action="gebinde"], button[data-action="geruch"], button[data-action="probe-note"]'),
        ).filter((el) => !el.disabled);
        const currentIndex = focusablesInRow.indexOf(target);
        if (currentIndex >= 0 && currentIndex < focusablesInRow.length - 1) {
          focusablesInRow[currentIndex + 1].focus();
          return;
        }

        const allRows = Array.from(probenContainer.querySelectorAll('.probe-row'));
        const rowIndex = allRows.indexOf(row);
        if (rowIndex >= 0 && rowIndex < allRows.length - 1) {
          const nextRow = allRows[rowIndex + 1];
          const nextFirst = nextRow.querySelector('input[name="probenbezeichnung"]');
          if (nextFirst) nextFirst.focus();
          return;
        }

        if (rowIndex === allRows.length - 1) {
          addProbe();
          const last = probenContainer.querySelector('.probe-row:last-child input[name="probenbezeichnung"]');
          if (last) last.focus();
        }
      });

      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (draftInFlight || commitInFlight) return;
        const payload = buildPayload();
        const canSend = await confirmBeforeSend(payload);
        if (!canSend) return;
        await sendOrder('/api/order/draft', { payload });
      });

      commitButton.addEventListener('click', async () => {
        if (commitInFlight || draftInFlight || commitClickLocked) return;
        commitClickLocked = true;
        setButtonLoading(commitButton, true, 'Sende...', 'Commit senden');
        try {
          const payload = buildPayload();
          const canSend = await confirmBeforeSend(payload);
          if (!canSend) return;
          payload.clientRequestId = createClientRequestId();

          if (appConfig.mode === 'writer') {
            const writerToken = sessionStorage.getItem('writerToken') || '';
            const writerLoginOk = sessionStorage.getItem('writerLoginOk') === '1';
            if (!writerToken || !writerLoginOk) {
              const data = { ok: false, message: 'Kein Writer Login vorhanden. Bitte zuerst in Settings anmelden.' };
              showToast('error', data.message);
              showErrorPanel(data.message, data);
              return;
            }
            await sendOrder('/api/order/commit', {
              extraHeaders: { 'x-ui-request': '1', 'x-writer-token': writerToken },
              payload,
              isCommit: true,
            });
            return;
          }

          await sendOrder('/api/order/commit', { payload, isCommit: true });
        } finally {
          commitClickLocked = false;
          if (!commitInFlight) {
            setButtonLoading(commitButton, false, 'Sende...', 'Commit senden');
          }
        }
      });

      retryCommitButton.addEventListener('click', async () => {
        if (commitInFlight || draftInFlight || !lastFailedCommitContext) return;
        await sendOrder('/api/order/commit', {
          extraHeaders: lastFailedCommitContext.extraHeaders || {},
          payload: { ...lastFailedCommitContext.payload },
          isCommit: true,
        });
      });

      async function bootstrap() {
        await loadConfig();
        await loadSingleParameterCatalog();
        await loadPackages();
        maybeOpenPackageBuilderEditFromQuery();
        await loadCustomers().catch(() => {});
        addProbe();
        applyHeaderDefaults();
        updateAdressePreviewUi();
        clearErrorPanel();
      }

      bootstrap().catch((error) => {
        showToast('error', error.message);
        showErrorPanel(error.message);
      });
    </script>
  </body>
</html>




